<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strivus</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0f172a">
    
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'action-blue': '#02B2FC',
                        'action-blue-hover': '#0298d6',
                        'accent-blue': '#0235FC',
                        'accent-teal': '#02FCC9',
                    }
                }
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="/js/config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        body { font-family: 'Inter', sans-serif; scroll-behavior: smooth; }
        .control-card { background-color: #1f2937; border: 1px solid #4b5563; border-radius: 1rem; padding: 1.5rem; }
        .result-card { background-color: #111827; border: 1px solid #374151; border-radius: 0.5rem; }
        #status-log { white-space: pre-wrap; font-family: monospace; font-size: 0.8rem; background-color: #000; padding: 1rem; border-radius: 0.5rem; border: 1px solid #374151; height: 150px; overflow-y: scroll; }
        details > summary { list-style: none; cursor: pointer; }
        details > summary::-webkit-details-marker { display: none; }
        details[open] summary ~ * { animation: sweep .5s ease-in-out; }
        @keyframes sweep {
            0%    {opacity: 0; transform: translateY(-10px)}
            100%  {opacity: 1; transform: translateY(0)}
        }
        @keyframes laugh_shake {
            0%, 100% { transform: translateY(0) rotate(0); }
            10% { transform: translateY(-6px) rotate(-2deg); }
            20% { transform: translateY(6px) rotate(2deg); }
            30% { transform: translateY(-4px) rotate(1deg); }
            40% { transform: translateY(4px) rotate(-1deg); }
            50% { transform: translateY(-3px) rotate(2deg); }
            60% { transform: translateY(3px) rotate(-2deg); }
            70% { transform: translateY(-2px) rotate(1deg); }
            80% { transform: translateY(2px) rotate(-1deg); }
            90% { transform: translateY(-1px) rotate(0); }
        }
        #ai-face.shake-laugh {
            animation: laugh_shake 0.5s cubic-bezier(.36,.07,.19,.97);
        }
        .muscle-slider, .skill-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 10px;
            background: linear-gradient(to right, #374151, #4f46e5);
            border-radius: 9999px;
            outline: none;
            cursor: pointer;
        }
        .muscle-slider::-webkit-slider-thumb, .skill-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 28px;
            height: 28px;
            background: #e2e8f0;
            border-radius: 50%;
            border: 3px solid #6366f1;
            transition: background-color 0.2s, transform 0.2s;
            cursor: grab;
        }
        .muscle-slider::-moz-range-thumb, .skill-slider::-moz-range-thumb {
            width: 28px;
            height: 28px;
            background: #e2e8f0;
            border-radius: 50%;
            border: 3px solid #6366f1;
            transition: background-color 0.2s, transform 0.2s;
            cursor: grab;
        }
        .muscle-slider:active::-webkit-slider-thumb, .skill-slider:active::-webkit-slider-thumb {
            transform: scale(1.1);
            cursor: grabbing;
        }
        .muscle-slider:active::-moz-range-thumb, .skill-slider:active::-moz-range-thumb {
            transform: scale(1.1);
            cursor: grabbing;
        }
        .muscle-slider:hover::-webkit-slider-thumb, .skill-slider:hover::-webkit-slider-thumb { background-color: #fff; }
        .muscle-slider:hover::-moz-range-thumb, .skill-slider:hover::-moz-range-thumb { background-color: #fff; }

        /* Mobile: Even larger touch targets for sliders */
        @media (max-width: 768px) {
            .muscle-slider, .skill-slider {
                height: 12px;
            }
            .muscle-slider::-webkit-slider-thumb, .skill-slider::-webkit-slider-thumb {
                width: 32px;
                height: 32px;
            }
            .muscle-slider::-moz-range-thumb, .skill-slider::-moz-range-thumb {
                width: 32px;
                height: 32px;
            }
        }
        .dynamic-feedback { transition: color 0.3s ease; }
        @keyframes dna_spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .dna-icon { animation: dna_spin 10s linear infinite; }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 15px 0px rgba(2, 178, 252, 0.5); }
            50% { box-shadow: 0 0 30px 8px rgba(2, 178, 252, 0.8); }
        }
        #animation-center-pulse { animation: pulse-glow 3s ease-in-out infinite; }
        #loader-overlay { transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; }
        details summary .chevron { transition: transform 0.2s ease-in-out; }
        details[open] summary .chevron { transform: rotate(180deg); }
        .popup-overlay { transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; }
        .popup-overlay.hidden { opacity: 0; visibility: hidden; }
        .popup-content {
            transition: transform 0.3s ease-in-out;
            max-height: 90vh;
            overflow-y: auto;
        }
        .popup-overlay.hidden .popup-content { transform: scale(0.95) translateY(-10px); }
        .tab-btn {
            padding: 0.75rem 1.5rem; border: none; background-color: transparent;
            color: #94a3b8;
            font-weight: 500; cursor: pointer;
            transition: color 0.2s, border-color 0.2s;
            border-bottom: 2px solid transparent; margin-bottom: -1px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .tab-btn.active-tab {
            color: #02B2FC;
            font-weight: 600;
            border-bottom-color: #02B2FC;
        }
        .tab-content.hidden { display: none; }
        .warmup-card {
            border: 1px solid #4b5563;
            background-color: #1f2937;
            border-radius: 1rem;
            padding: 1.5rem;
        }
        .prose ul { padding-left: 1.25rem; }
        .prose li { margin-top: 0.25em; margin-bottom: 0.25em; }
        #timer-status.status-work { color: #f43f5e; }
        #timer-status.status-rest { color: #22c55e; }
        #timer-status.status-prep { color: #38bdf8; }
        #timer-status.status-done { color: #a78bfa; }
        .timer-btn {
            padding: 0.75rem 1.5rem; font-weight: 600; border-radius: 0.5rem;
            transition: background-color 0.2s, opacity 0.2s;
        }
        .timer-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .range-slider-container {
            position: relative;
            height: 30px;
            display: flex;
            align-items: center;
        }
        .range-slider-container::before {
            content: '';
            background-color: #374151;
            width: 100%;
            height: 5px;
            border-radius: 3px;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
        }
        .range-slider-container input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
            position: absolute;
            left: 0;
            pointer-events: none;
        }
        .range-slider-container input[type=range]::-webkit-slider-runnable-track {
            height: 5px;
            background: transparent;
            border: none;
            border-radius: 3px;
        }
        .range-slider-container input[type=range]::-moz-range-track {
            height: 5px;
            background: transparent;
            border: none;
            border-radius: 3px;
        }
        .range-slider-container input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 18px;
            width: 18px;
            background-color: #e2e8f0;
            border-radius: 50%;
            border: 2px solid #6366f1;
            margin-top: -6.5px;
            z-index: 2;
            position: relative;
            pointer-events: auto;
        }
        .range-slider-container input[type=range]::-moz-range-thumb {
            height: 18px;
            width: 18px;
            background-color: #e2e8f0;
            border-radius: 50%;
            border: 2px solid #6366f1;
            z-index: 2;
            position: relative;
            pointer-events: auto;
        }
        .slider-track {
            width: 100%;
            height: 5px;
            background: #6366f1;
            position: absolute;
            border-radius: 3px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1;
        }
        .tooltip-container { position: relative; display: inline-flex; align-items: center; }
        .tooltip {
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #0f172a;
            color: #cbd5e1;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #334155;
            font-size: 0.8rem;
            line-height: 1.2;
            width: max-content;
            max-width: 250px;
            z-index: 10;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
        }
        .tooltip-container:hover .tooltip {
            opacity: 1;
            visibility: visible;
        }
        .chip-group {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.5rem;
        }
        @media (max-width: 375px) {
            .chip-group {
                grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
                gap: 0.25rem;
            }
        }
        .chip-label input { display: none; }
        .chip-label span {
            display: block;
            text-align: center;
            padding: 0.5rem 0.75rem;
            background-color: #334155;
            color: #cbd5e1;
            border-radius: 9999px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            font-size: 0.875rem;
        }
        .chip-label input:checked + span {
            background-color: #02B2FC;
            color: white;
            font-weight: 500;
        }
        .chip-label:hover span { background-color: #475569; }
        .persona-selector { display: flex; }
        .persona-card {
            padding: 1rem;
            border: 2px solid #334155;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: border-color 0.2s, background-color 0.2s;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        .persona-selector input:checked + .persona-card {
            border-color: #02B2FC;
            background-color: rgba(2, 178, 252, 0.1);
        }
        .persona-selector:hover .persona-card {
            border-color: #475569;
        }
        #ai-guide-container {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
            bottom: 1rem;
            right: 1rem;
            max-width: 32rem;
        }
        #ai-guide-container.visible {
            opacity: 1;
            transform: translateY(0);
        }
        #ai-face {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        #ai-face:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(2, 178, 252, 0.6);
        }

        /* Mobile Bottom Navigation */
        .mobile-nav-btn {
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }
        .mobile-nav-btn.active {
            color: #02B2FC;
        }
        .mobile-nav-btn:active {
            transform: scale(0.95);
        }

        /* Tablet and smaller */
        @media (max-width: 1024px) {
            body {
                padding-bottom: 80px;
            }
            .control-card {
                padding: 1rem;
                border-radius: 0.75rem;
            }
            button {
                min-height: 44px;
            }
            input[type="number"], input[type="text"], select {
                min-height: 44px;
            }
        }

        /* Mobile: Standard phones (375px - 768px) */
        @media (max-width: 768px) {
            #ai-guide-container {
                bottom: 80px !important;
                right: 0.5rem !important;
                max-width: 180px;
            }
            #ai-text-bubble {
                max-width: 160px;
                padding: 0.5rem;
                font-size: 0.75rem;
                line-height: 1.3;
            }
            #ai-face {
                width: 56px !important;
                height: 56px !important;
                flex-shrink: 0;
            }
        }

        /* Extra small phones only */
        @media (max-width: 375px) {
            body {
                padding-bottom: 80px;
            }
            .control-card {
                padding: 0.75rem;
                margin: 0.25rem;
                border-radius: 0.5rem;
            }
            #ai-guide-container {
                bottom: 70px !important;
                right: 0.25rem !important;
                max-width: 60px;
            }
            #ai-text-bubble {
                display: none;
            }
            #ai-face {
                width: 48px !important;
                height: 48px !important;
                border-width: 1px !important;
            }
            button {
                padding: 0.5rem 0.75rem;
                font-size: 0.875rem;
                white-space: normal;
                word-wrap: break-word;
            }
            .tab-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.875rem;
                padding: 0.5rem 0.75rem;
            }
            #timer-start-btn, #timer-pause-btn, #timer-next-btn, #timer-end-btn {
                flex: 1;
                min-width: auto;
                font-size: 0.75rem;
                padding: 0.5rem 0.25rem;
            }
        }

        /* Tablet: Adjust AI character */
        @media (min-width: 768px) and (max-width: 1024px) {
            #ai-face {
                width: 80px;
                height: 80px;
            }
        }

        /* Desktop: Full layout */
        @media (min-width: 1025px) {
            body {
                padding-bottom: 0;
            }
            #ai-guide-container {
                bottom: 1rem !important;
                right: 1rem !important;
                max-width: 32rem;
            }
            #ai-text-bubble {
                max-width: 200px;
                padding: 1rem;
                font-size: 1rem;
                line-height: 1.5;
            }
            #ai-face {
                width: 96px !important;
                height: 96px !important;
            }
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-300">

    <div id="ai-guide-container" class="fixed z-40 flex items-end gap-2">
        <div id="ai-text-bubble" class="bg-slate-800 border-2 border-action-blue rounded-lg p-4 text-slate-200 shadow-lg relative flex items-center">
            <p id="ai-dialogue" class="text-sm"></p>
            <div class="absolute bottom-0 -right-2 transform -translate-x-1/2 translate-y-1/2 rotate-45 w-4 h-4 bg-slate-800 border-r-2 border-b-2 border-action-blue"></div>
        </div>
        <img id="ai-face" src="assets/neutralslightlynotsmiling.png" alt="AI Guide Face" class="rounded-full border-2 border-action-blue bg-slate-700 object-cover flex-shrink-0">
    </div>

    <div id="loader-overlay" class="hidden fixed inset-0 z-50 bg-slate-900/80 backdrop-blur-sm flex flex-col items-center justify-center text-center p-4">
        <div id="animation-center-pulse" class="relative w-40 h-40 rounded-full border-2 border-accent-blue flex flex-col items-center justify-center bg-slate-800">
            <span class="text-xs text-action-blue font-semibold">Evolving Fitness</span>
            <span id="animation-fitness-value" class="text-3xl font-bold text-white">0.000</span>
            <span id="animation-generation-count" class="text-sm text-slate-400">Gen 0</span>
        </div>
        <div class="absolute inset-0 flex items-center justify-center opacity-20 -z-10">
            <svg class="w-64 h-64 text-accent-blue dna-icon" xmlns="http://www.w.org/2000/svg" fill="none" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M16.882 2.31a.75.75 0 0 0-1.05.21l-3.67 5.139a.75.75 0 0 1-1.123.142l-1.5-1.2a.75.75 0 0 0-.918 1.18l1.5 1.2a2.25 2.25 0 0 0 2.754-.427l3.67-5.138a.75.75 0 0 0-.84-1.26Zm-9.764 0a.75.75 0 0 1 .84 1.26l-3.67 5.138a2.25 2.25 0 0 0-2.754.427l-1.5-1.2a.75.75 0 0 1 .918-1.18l1.5 1.2a.75.75 0 0 1 1.123-.142L7.118 2.52a.75.75 0 0 1-.21-1.05C7.02 1.258 7.21 1 7.5 1c.18 0 .358.068.49.208Zm10.134 9.482a.75.75 0 0 0-1.18-.918l-1.2 1.5a.75.75 0 0 1-1.26-.84l5.138-3.67a.75.75 0 0 0-.21-1.05c-.212-.112-.473-.08-.651.082L12.52 11.12a2.25 2.25 0 0 0-.427 2.754l1.2 1.5a.75.75 0 0 0 1.18.918l1.2-1.5a.75.75 0 0 1 1.26.84l-5.138 3.67a.75.75 0 0 0 .21 1.05c.211.112.473.08.65-.082l5.233-3.738a2.25 2.25 0 0 0 .427-2.754l-1.2-1.5Zm-10.886-3.74a.75.75 0 0 0-1.05-.21L2.31 12.118a.75.75 0 0 0 1.26.84l1.5-1.2a.75.75 0 0 1 .918 1.18l-1.5 1.2a2.25 2.25 0 0 0-.427 2.754l3.738 5.233c.18.252.49.33.762.22a.75.75 0 0 0 .49-.49c.112-.273.037-.582-.22-.763l-3.738-5.232a.75.75 0 0 1 .142-1.123l1.5-1.2a.75.75 0 0 0-.918-1.18l-1.5 1.2a2.25 2.25 0 0 0-2.754.427L1.22 8.48a.75.75 0 0 0 .082-.651c.112-.212.34-.321.551-.27l3.67 5.138a.75.75 0 0 1 .84-1.26l-1.2-1.5a.75.75 0 0 0-.918-1.18Z" clip-rule="evenodd"/></svg>
        </div>
        <div class="w-full max-w-md bg-slate-700 rounded-full h-2.5 mt-6">
            <div id="animation-progress-bar" class="bg-action-blue h-2.5 rounded-full" style="width: 0%"></div>
        </div>
    </div>
    
    <div id="principle-info-popup" class="popup-overlay hidden fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-75 p-4">
        <div class="popup-content bg-slate-800 border border-slate-600 rounded-2xl max-w-2xl w-full p-8 shadow-2xl relative">
             <button id="close-principle-info-btn" class="absolute top-4 right-4 text-slate-500 hover:text-white transition-colors">
                 <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
            </button>
            <h2 class="text-3xl font-bold text-white mb-6">Training Principle Explanations</h2>
            <div class="space-y-6 text-slate-300">
                <div>
                    <h3 class="font-semibold text-lg text-action-blue">Standard</h3>
                    <p class="text-slate-400 mt-1">The most straightforward approach. After your warm-up, you perform all working sets for an exercise with the <strong>same weight</strong>. This is ideal for building a solid foundation, focusing on form, and consistently tracking strength progress over time.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-action-blue">Progressive</h3>
                    <p class="text-slate-400 mt-1">You start with your highest rep count and lightest working weight, then <strong>increase the weight</strong> while <strong>decreasing the reps</strong> on each subsequent set. This method allows you to handle heavier loads as you fatigue, effectively training for strength and hypertrophy.</p>
                    <p class="text-xs text-slate-500 mt-2"><em>Example: Set 1: 12 reps @ 50kg, Set 2: 10 reps @ 55kg, Set 3: 8 reps @ 60kg.</em></p>
                </div>
                 <div>
                    <h3 class="font-semibold text-lg text-action-blue">Degressive (Drop Set)</h3>
                    <p class="text-slate-400 mt-1">Perform your regular sets at a constant weight. On the <strong>final set</strong>, immediately after finishing your target reps, <strong>reduce the weight</strong> by 20-30% and perform as many more reps as possible to failure. This is a high-intensity technique to maximize muscle fatigue and stimulate growth.</p>
                </div>
                 <div>
                    <h3 class="font-semibold text-lg text-action-blue">Pyramid</h3>
                    <p class="text-slate-400 mt-1">A classic bodybuilding technique. You start with lighter weight and higher reps, progressively increase the weight and decrease reps to a "peak" heavy set, and then reverse the process. This plan uses a half-pyramid followed by a back-off set for high volume and muscle endurance.</p>
                    <p class="text-xs text-slate-500 mt-2"><em>Example: Set 1: 12 reps @ 50kg, Set 2: 10 reps @ 55kg, Set 3: 8 reps @ 60kg, Set 4 (back-off): 12 reps @ 50kg.</em></p>
                </div>
            </div>
        </div>
    </div>

    <div id="premium-upgrade-modal" class="popup-overlay hidden fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-80 p-4">
        <div class="popup-content bg-gradient-to-br from-slate-900 to-slate-800 border-2 border-yellow-500 rounded-2xl max-w-lg w-full p-8 shadow-2xl relative">
            <button id="close-premium-modal" class="absolute top-4 right-4 text-slate-400 hover:text-white text-2xl font-bold transition">&times;</button>

            <div class="text-center mb-6">
                <div class="text-6xl mb-4">‚≠ê</div>
                <h2 class="text-3xl font-bold text-white mb-2">Upgrade to Pro</h2>
                <p class="text-slate-300">Unlock advanced fitness tracking and analytics</p>
            </div>

            <div class="bg-slate-800/50 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold text-yellow-400 mb-4">Pro Features Include:</h3>
                <ul class="space-y-3 text-slate-300">
                    <li class="flex items-start gap-3">
                        <span class="text-green-400 text-xl">‚úì</span>
                        <span><strong>Condition Tab</strong> - Track fitness, fatigue, and recovery metrics</span>
                    </li>
                    <li class="flex items-start gap-3">
                        <span class="text-green-400 text-xl">‚úì</span>
                        <span><strong>ACWR Analysis</strong> - Monitor training load and injury risk</span>
                    </li>
                    <li class="flex items-start gap-3">
                        <span class="text-green-400 text-xl">‚úì</span>
                        <span><strong>Muscle Readiness</strong> - Per-muscle recovery tracking</span>
                    </li>
                    <li class="flex items-start gap-3">
                        <span class="text-green-400 text-xl">‚úì</span>
                        <span><strong>Daily Check-ins</strong> - Log sleep, stress, and wellness</span>
                    </li>
                    <li class="flex items-start gap-3">
                        <span class="text-green-400 text-xl">‚úì</span>
                        <span><strong>Performance Trends</strong> - Long-term progress visualization</span>
                    </li>
                </ul>
            </div>

            <div class="text-center mb-4">
                <div class="text-3xl font-bold text-white mb-1">$9.99<span class="text-lg text-slate-400">/month</span></div>
                <p class="text-sm text-slate-400">Cancel anytime</p>
            </div>

            <button id="upgrade-to-pro-btn" class="w-full bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-600 hover:to-orange-600 text-white font-bold py-4 px-6 rounded-lg transition shadow-lg text-lg">
                Upgrade Now
            </button>

            <p class="text-center text-xs text-slate-500 mt-4">Powered by Stripe - Secure Payment Processing</p>
        </div>
    </div>

    <div id="subscription-management-modal" class="popup-overlay hidden fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-80 p-4">
        <div class="popup-content bg-gradient-to-br from-slate-900 to-slate-800 border-2 border-green-500 rounded-2xl max-w-lg w-full p-8 shadow-2xl relative">
            <button id="close-subscription-modal" class="absolute top-4 right-4 text-slate-400 hover:text-white text-2xl font-bold transition">&times;</button>

            <div class="text-center mb-6">
                <div class="text-6xl mb-4">&#9733;</div>
                <h2 class="text-3xl font-bold text-white mb-2">Pro Subscription</h2>
                <p class="text-green-400 font-semibold">Active</p>
            </div>

            <div class="bg-slate-800/50 rounded-lg p-6 mb-6">
                <div class="space-y-4">
                    <div class="flex justify-between items-center text-slate-300">
                        <span>Status:</span>
                        <span id="subscription-status-text" class="font-semibold text-green-400">Active</span>
                    </div>
                    <div class="flex justify-between items-center text-slate-300">
                        <span>Current period ends:</span>
                        <span id="subscription-period-end" class="font-semibold">-</span>
                    </div>
                    <div id="cancellation-notice" class="hidden bg-yellow-500/20 border border-yellow-500/50 rounded-lg p-4 mt-4">
                        <p class="text-yellow-400 text-sm">Your subscription is set to cancel at the end of the billing period. You'll continue to have access until then.</p>
                    </div>
                </div>
            </div>

            <div id="cancel-subscription-section">
                <button id="cancel-subscription-btn" class="w-full bg-slate-700 hover:bg-red-600 text-slate-300 hover:text-white font-semibold py-3 px-6 rounded-lg transition">
                    Cancel Subscription
                </button>
                <p class="text-center text-xs text-slate-500 mt-3">Cancellation takes effect at the end of your billing period</p>
            </div>

            <div id="subscription-canceled-section" class="hidden text-center">
                <p class="text-slate-400">Your subscription will end on <span id="cancel-end-date" class="text-white font-semibold">-</span></p>
                <p class="text-sm text-slate-500 mt-2">You can continue using Pro features until then</p>
            </div>
        </div>
    </div>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl pb-40">
        <header class="mb-4 md:mb-8 pb-3 md:pb-4 border-b border-slate-700">
            <div class="flex items-center justify-between gap-2">
                <!-- Logo and Title - More compact on mobile -->
                <div class="flex items-center gap-2 md:gap-4">
                    <img src="icon.svg" alt="Fit Alchemist Icon" class="h-8 w-8 md:h-12 md:w-12">
                    <div>
                        <h1 class="text-xl md:text-3xl lg:text-4xl font-bold text-white">Strivus</h1>
                        <p class="text-slate-400 text-xs md:text-sm mt-0.5 md:mt-1 hidden sm:block">Your AI-powered training partner</p>
                    </div>
                </div>

                <!-- User controls - Compact on mobile -->
                <div class="flex items-center gap-2 md:gap-3">
                    <span class="text-slate-300 text-xs md:text-sm hidden sm:inline">Hello, <span data-user-name class="font-semibold text-action-blue">User</span></span>
                    <button id="go-pro-btn" class="hidden bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-600 hover:to-orange-600 text-white font-bold py-1.5 px-3 md:py-2 md:px-5 rounded-lg transition text-xs md:text-sm shadow-lg">
                        &#9733;<span class="hidden sm:inline"> Go Pro</span>
                    </button>
                    <button id="manage-subscription-btn" class="hidden bg-green-600 hover:bg-green-500 text-white font-semibold py-1.5 px-2 md:py-2 md:px-4 rounded-lg transition text-xs md:text-sm">
                        &#9733;<span class="hidden sm:inline"> Pro</span>
                    </button>
                    <button data-logout-btn class="bg-slate-600 hover:bg-slate-500 text-white font-semibold py-1.5 px-2 md:py-2 md:px-4 rounded-lg transition text-xs md:text-sm">
                        <span class="hidden sm:inline">Logout</span>
                        <span class="sm:hidden">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"/>
                            </svg>
                        </span>
                    </button>
                </div>
            </div>
        </header>

        <!-- Desktop Tab Navigation (hidden on mobile) -->
        <div class="mb-8 hidden md:block">
            <div class="border-b border-slate-700">
                <nav class="-mb-px flex space-x-8" aria-label="Tabs">
                    <button id="tab-generator" class="tab-btn active-tab">Training Generator</button>
                    <button id="tab-record" class="tab-btn">Record Training</button>
                    <button id="tab-condition" class="tab-btn relative">
                        Condition
                        <span id="condition-pro-badge" class="hidden ml-1 text-xs bg-yellow-500 text-slate-900 px-2 py-0.5 rounded font-bold">PRO</span>
                    </button>
                    <button id="tab-history" class="tab-btn">Training History</button>
                </nav>
            </div>
        </div>

        <!-- Mobile Page Title (shown on mobile only) -->
        <div class="mb-6 md:hidden">
            <h2 id="mobile-page-title" class="text-2xl font-bold text-white">Training Generator</h2>
        </div>
        <div id="main-content-area">

            <div id="content-generator" class="tab-content">
                <!-- HERO SECTION: Muscle Sliders (THE MAIN FEATURE) -->
                <div class="control-card mb-6 border-2 border-action-blue/50">
                    <div class="mb-4 flex items-center justify-between">
                        <div>
                            <h2 class="text-2xl md:text-3xl font-bold text-white">üéØ Target Muscles</h2>
                            <p class="text-sm text-slate-400 mt-1">Slide to set muscle priorities - this is your main control</p>
                        </div>
                        <button id="auto-balance-btn" class="bg-action-blue hover:bg-action-blue-hover text-white font-bold py-3 px-4 rounded-lg transition text-sm min-h-[44px] whitespace-nowrap">
                            ‚ö° Balance
                        </button>
                    </div>
                    <div id="readiness-indicator" class="hidden mb-4 p-3 bg-slate-800 rounded-lg border border-slate-600">
                        <p class="text-xs text-slate-400 mb-2">Based on your recovery:</p>
                        <div id="readiness-summary" class="text-sm text-slate-200"></div>
                    </div>
                    <div id="muscle-sliders" class="space-y-4"></div>
                </div>

                <!-- SECTION 2: Persona (Quick Config) -->
                <div id="card-workout-settings" class="control-card mb-6">
                    <h3 class="text-lg md:text-xl font-bold text-white mb-3">üé≠ Choose Your Style</h3>
                    <p class="text-xs md:text-sm text-slate-400 mb-4">This auto-fills all settings below - Bodybuilder, Powerlifter, Athlete, etc.</p>
                    <div id="persona-selector" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 md:gap-3"></div>
                </div>

                <!-- SECTION 3: Generate Button (Prominent) -->
                <div class="mb-6">
                    <button id="generate-btn" class="w-full bg-action-blue hover:bg-action-blue-hover text-white font-bold py-6 px-6 rounded-lg text-lg md:text-xl transition disabled:bg-slate-500 shadow-2xl min-h-[64px] transform hover:scale-105 active:scale-95" disabled>
                        ‚ö° GENERATE WORKOUT ‚ö°
                    </button>
                    <button id="generate-warmup-btn" class="w-full bg-slate-700 hover:bg-slate-600 text-white font-semibold py-3 px-4 rounded-lg text-sm md:text-base transition disabled:bg-slate-600 mt-3 min-h-[48px]" disabled>
                        Generate Warmup & Cooldown
                    </button>
                </div>

                <!-- SECTION 4: Advanced Settings (Collapsible) -->
                <details id="card-equipment" class="control-card">
                    <summary class="flex items-center justify-between cursor-pointer text-lg font-semibold text-white hover:text-action-blue transition py-2">
                        <span>‚öôÔ∏è Advanced Settings</span>
                        <svg class="w-6 h-6 transition" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>
                    </summary>

                    <div class="space-y-6 mt-6 pt-6 border-t border-slate-700">
                        <!-- Sub-section: Equipment -->
                        <div>
                            <h4 class="text-base font-semibold text-white mb-3">Equipment Available</h4>
                            <div id="equipment-checkboxes" class="space-y-2">
                                <p class="text-slate-500 text-sm">Loading...</p>
                            </div>
                        </div>

                        <!-- Sub-section: Core Config -->
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-slate-300 font-semibold mb-2 text-sm">Exercises</label>
                                <input type="number" id="num-exercises" value="5" min="3" max="10" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 min-h-[44px] text-white">
                            </div>
                            <div>
                                <label class="block text-slate-300 font-semibold mb-2 text-sm">Time (minutes)</label>
                                <input type="number" id="total-time" value="60" min="15" max="180" step="5" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 min-h-[44px] text-white">
                            </div>
                        </div>

                        <!-- Sub-section: Training Details -->
                        <div>
                            <h4 class="text-base font-semibold text-white mb-3">Training Details</h4>
                            <div class="space-y-3">
                                <div>
                                    <label class="block text-slate-400 mb-2 text-sm tooltip-container">
                                        <span>Difficulty: <span id="difficulty-value" class="font-semibold text-white">1 - 5</span></span>
                                    </label>
                                    <div class="range-slider-container">
                                        <div class="slider-track"></div>
                                        <input type="range" id="difficulty-min" min="1" max="5" value="1" class="z-10">
                                        <input type="range" id="difficulty-max" min="1" max="5" value="5">
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-slate-400 mb-2 text-sm">Focus</label>
                                    <div id="focus-toggles" class="flex flex-wrap gap-2"></div>
                                </div>
                                <div>
                                    <label class="block text-slate-400 mb-2 text-sm">Principle</label>
                                    <div id="principle-toggles" class="flex flex-wrap gap-2"></div>
                                </div>
                                <div>
                                    <label class="block text-slate-400 mb-2 text-sm">Superset</label>
                                    <div id="superset-toggles" class="flex flex-wrap gap-2"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Sub-section: Sports & Mechanics -->
                        <div id="sports-selector-container" class="hidden">
                            <label class="block text-white font-semibold mb-2 text-sm">Sport</label>
                            <div id="sports-checkboxes" class="chip-group"></div>
                        </div>

                        <div id="skill-progression-container" class="hidden">
                            <label class="block text-white font-semibold mb-2 text-sm">Skill Level</label>
                            <div id="skill-sliders" class="space-y-2"></div>
                        </div>

                        <details class="border border-slate-700 rounded-lg p-3">
                            <summary class="font-medium text-slate-300 cursor-pointer hover:text-action-blue text-sm">More Filters...</summary>
                            <div class="pt-4 grid grid-cols-1 sm:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-slate-400 mb-2 text-sm">Mechanics</label>
                                    <div id="mechanics-checkboxes" class="chip-group"></div>
                                </div>
                                <div>
                                    <label class="block text-slate-400 mb-2 text-sm">Exercise Type</label>
                                    <div id="type-checkboxes" class="chip-group"></div>
                                </div>
                            </div>
                        </details>
                    </div>
                </details>

                <!-- SECTION 5: Results & Logs -->
                <div class="control-card mt-8">
                    <div id="card-generate" class="mb-6">
                        <div class="mt-6">
                            <details id="generation-details">
                                <summary class="flex justify-between items-center text-base md:text-lg font-semibold text-white cursor-pointer hover:text-action-blue transition-colors">
                                    <span>üìã Generation Log</span>
                                    <svg class="h-5 w-5 chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                                </summary>
                                <div id="status-log" class="mt-4">Initializing...</div>
                            </details>
                        </div>
                    </div>

                    <div id="results-anchor" class="control-card">
                        <div class="flex border-b border-slate-700 mb-4">
                            <button id="tab-workout" class="tab-btn active-tab">Workout Result</button>
                            <button id="tab-timer" class="tab-btn">Workout Timer</button>
                            <button id="tab-warmup" class="tab-btn">Warm-up / Cool-down</button>
                        </div>

                        <div id="content-workout" class="tab-content">
                            <div id="workout-results">
                                <p class="text-slate-500">Your generated workout will appear here.</p>
                            </div>
                        </div>
                        
                        <div id="content-timer" class="tab-content hidden">
                            <div id="timer-ui-container" class="text-center p-4 max-w-lg mx-auto">
                                <div class="w-full bg-slate-700 rounded-full h-4 mb-4">
                                    <div id="timer-progress-bar" class="bg-action-blue h-4 rounded-full transition-all duration-1000 ease-linear" style="width: 0%"></div>
                                </div>
                                <p class="text-sm text-slate-400" id="timer-progress-text">0:00 / 0:00</p>

                                <div class="my-6">
                                    <h3 id="timer-exercise-name" class="text-2xl sm:text-3xl font-bold text-white mb-1 h-16">No Workout Generated</h3>
                                    <p id="timer-set-info" class="text-lg text-slate-400 h-8"></p>
                                </div>
                                
                                <div class="my-6">
                                    <p id="timer-display" class="text-7xl sm:text-8xl font-bold font-mono text-white tabular-nums">00:00</p>
                                    <p id="timer-status" class="text-3xl font-bold uppercase tracking-widest mt-2 h-10">IDLE</p>
                                </div>

                                <div class="flex items-center justify-center gap-4 mt-6">
                                    <button id="timer-start-btn" class="timer-btn bg-action-blue hover:bg-action-blue-hover text-white" disabled>Start Workout</button>
                                    <button id="timer-pause-btn" class="timer-btn bg-amber-500 hover:bg-amber-600 text-white hidden">Pause</button>
                                    <button id="timer-next-btn" class="timer-btn bg-slate-600 hover:bg-slate-500 text-white hidden">Skip</button>
                                    <button id="timer-end-btn" class="timer-btn bg-rose-600 hover:bg-rose-700 text-white hidden">End Workout</button>
                                </div>
                            </div>
                        </div>

                        <div id="content-warmup" class="tab-content hidden">
                            <div class="mb-6">
                                <label for="warmup-select" class="block text-slate-400 mb-2">Select an activity for its recommended routine:</label>
                                <select id="warmup-select" class="w-full max-w-md bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 focus:ring-2 focus:ring-accent-blue focus:border-accent-blue"></select>
                            </div>
                            <div id="warmup-display" class="space-y-6">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="content-record" class="tab-content hidden">
                </div>
            <div id="content-condition" class="tab-content hidden">
                </div>
            <div id="content-history" class="tab-content hidden">
                </div>
            </div>
    </div>

<script>
/* --- YouTube Embed Helper --- */
function getYoutubeEmbedUrl(rawUrl) {
    if (!rawUrl || typeof rawUrl !== 'string') return null;
    const url = rawUrl.trim().replace(/^"+|"+$/g, '');
    let videoId = null;
    
    const patterns = [
        /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?|shorts)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/
    ];

    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match && match[1]) {
            videoId = match[1];
            break;
        }
    }
    
    return videoId ? `https://www.youtube.com/embed/${videoId}` : null;
}
</script>

<script>
    let ALL_EXERCISES = [];
    let SKILL_PROGRESSIONS = {};
    let muscleProfileChart = null; 
    let acwrChart = null;
    let performanceTrendsChart = null; // NEW: Chart instance for FFM
    let checkinHistoryChart = null;
    let CURRENT_WORKOUT_STRUCTURE = [];
    let LAST_PREFERENCES = {};
    let activeCharts = {};
    let WORKOUT_TO_RECORD = null; 
    
    const MUSCLE_LIST = ["Lats", "Chest", "Deltoids", "Biceps", "Triceps", "Abs", "Forearm", "Quads", "Hams", "Calfs", "Glutes", "Lumbar", "Trapezius"];
    const MAIN_EQUIPMENT_LIST = new Set(["Barbell", "Bench", "Bodyweight", "Cable", "Dumbbell", "Machine", "Pull-Up Bar", "Kettlebell", "Weight"]);
    const SPORT_MUSCLE_VECTORS = {
        // Vector order: Lats, Chest, Deltoids, Biceps, Triceps, Abs, Forearm, Quads, Hams, Calfs, Glutes, Lumbar, Trapezius
        'Jiu-Jitsu':  [0.8, 0.2, 0.4, 0.5, 0.2, 0.7, 0.9, 0.3, 0.4, 0.1, 0.6, 0.6, 0.3],
        'Bouldering': [1.0, 0.2, 0.5, 0.7, 0.1, 0.8, 1.0, 0.2, 0.2, 0.1, 0.3, 0.4, 0.5],
        'Climbing':   [1.0, 0.2, 0.5, 0.7, 0.1, 0.8, 1.0, 0.2, 0.2, 0.1, 0.3, 0.4, 0.5], // Alias for Bouldering
        'Running':    [0.1, 0.1, 0.1, 0.0, 0.0, 0.4, 0.0, 0.9, 0.8, 1.0, 0.7, 0.3, 0.1],
        'Biking':     [0.0, 0.0, 0.1, 0.0, 0.0, 0.2, 0.0, 1.0, 0.6, 0.7, 0.8, 0.2, 0.0],
        'Swimming':   [1.0, 0.5, 0.9, 0.2, 0.6, 0.6, 0.3, 0.4, 0.2, 0.2, 0.2, 0.3, 0.4],
        'Volleyball': [0.2, 0.2, 0.8, 0.2, 0.3, 0.6, 0.2, 0.9, 0.6, 0.9, 0.8, 0.3, 0.2],
        'Football':   [0.2, 0.2, 0.3, 0.1, 0.1, 0.6, 0.1, 1.0, 1.0, 0.9, 0.9, 0.4, 0.1],
    };
    
    const EQUIPMENT_ICONS = {
        'Barbell': `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12h20"/><path d="M4 8v8"/><path d="M20 8v8"/><path d="M7 7v10"/><path d="M17 7v10"/></svg>`,
        'Dumbbell': `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.63 15.63a2 2 0 0 1-2.26 2.26"/><path d="M12 12H2v0a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v0a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2Z"/><path d="M8.37 8.37a2 2 0 0 1 2.26-2.26"/><path d="M12 12h10v0a2 2 0 0 0-2 2h-4a2 2 0 0 0-2-2v0a2 2 0 0 0 2-2h4a2 2 0 0 0 2 2Z"/></svg>`,
        'Kettlebell': `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6.5 6.5a6 6 0 1 1 11 0"/><path d="M9 8.5V7a3 3 0 0 1 6 0v1.5"/><path d="M12 13V7"/><path d="M5 14a7.5 7.5 0 0 0 14 0"/><path d="M5 14a7.5 7.5 0 0 1 14 0"/></svg>`,
        'Bodyweight': `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="1"/><path d="m9 20 3-6 3 6"/><path d="m6 8 6 2 6-2"/><path d="M12 10v4"/></svg>`,
        'Cable': `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12h16"/><path d="M12 4v16"/><circle cx="12" cy="12" r="3"/></svg>`,
        'Machine': `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 18.7a4.5 4.5 0 1 0-7.4-4.4c.3.2.5.5.8.8l4.4 4.4a.5.5 0 0 0 .7.1Z"/><path d="m13.7 9.8 4.5-4.5"/><path d="M10.4 12s-1.8-1.5-2.6-2.2c-.8-.7-1.4-1.3-1.4-2.3 0-1.4 1-2.3 2.3-2.3 1.3 0 2.3 1 2.3 2.3S11 9 10.4 12Z"/><path d="M12.3 13.6 2.4 3.7"/><path d="M13.6 12.3 3.7 2.4"/><path d="m20.2 17-4.5-4.5"/></svg>`,
        'Bench': `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 8h16"/><path d="M6 12v4"/><path d="M18 12v4"/><path d="M12 12V8"/></svg>`,
        'Pull-Up Bar': `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 14h16"/><path d="M4 6h16"/><path d="M12 6v8"/></svg>`,
        'Default': `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12.4 12.4 7.2 7.2"/><path d="m21.6 21.6-7.2-7.2"/><path d="M16 8a4 4 0 1 0-8 0 4 4 0 0 0 8 0Z"/><path d="M12 12V4"/><path d="M4 4v2.4"/><path d="M4 12H2"/><path d="M10 4H8"/><path d="M4 10v2"/></svg>`
    };
    
    const WARMUP_DATA = { "Global Warm-up": { warmup: [ { phase: "Raise", duration: "5-10 min", exercises: "<ul><li>Light Jogging, Cycling, or Jumping Jacks.</li></ul>", rationale: "Elevates core temperature, increases heart rate, and improves blood flow to muscles." }, { phase: "Activate & Mobilize", duration: "5-10 min", exercises: "<b>Perform 1-2 rounds:</b><ul><li>Leg Swings (Forward & Lateral) x10/side</li><li>Arm Circles (Forward & Backward) x10/side</li><li>Cat-Cow x10</li><li>Bird-Dog x8/side</li><li>Glute Bridges x15</li></ul>", rationale: "Activates key stabilizing muscles like the glutes and core, while mobilizing the hips, shoulders, and spine through their full range of motion." }, { phase: "Potentiate", duration: "3-5 min", exercises: "<ul><li>Pogo Jumps (2 sets of 15 seconds)</li><li>2-3 short accelerations over 15-20 yards (build to 75% speed).</li></ul>", rationale: "Primes the central nervous system for more intense activity and improves the muscles' ability to produce force rapidly." } ], cooldown: { stage1: "5-10 minutes of light aerobic activity, such as walking or easy cycling, to gradually lower heart rate.", stage2: "5-15 minutes of static stretching, focusing on major muscle groups used. Hold each stretch for 20-60 seconds." } }, "Jiu-Jitsu": { warmup: [ { phase: "Raise", duration: "5-7 min", exercises: "<ul><li>Light Jogging/Jumping Jacks (2 min)</li><li>BJJ Locomotion Drills: Shrimping, Reverse Shrimping, Forward/Backward Rolls, Bear Crawls (3-5 min)</li></ul>", rationale: "Begin with general movement then transition to BJJ-specific locomotion to rehearse foundational mechanics while increasing core temperature." }, { phase: "Activate & Mobilize", duration: "7-10 min", exercises: "<b>Mobility (2 rounds):</b><ul><li>90/90 Hip Switches (10/side)</li><li>Cat-Cow (10 reps)</li><li>Thread the Needle (8/side)</li></ul><b>Activation (2 rounds):</b><ul><li>Glute Bridges (15 reps)</li><li>Side Plank (30s/side)</li></ul>", rationale: "Targets critical areas for grappling: hips for guard work, thoracic spine for rotation, and activates the posterior chain and core for stability and power." }, { phase: "Potentiate", duration: "3-5 min", exercises: "<ul><li>Technical Stand-ups (10/side)</li><li>Partner Drills (2-3 min): Light grip fighting or low-intensity flow drilling.</li></ul>", rationale: "Integrates full-body coordination and primes the exact neural pathways and reaction times used in live rolling." } ], cooldown: { stage1: "5 minutes of light movement, like slow shrimping or flow drilling with a partner.", stage2: "Focus on static stretches for the hips (Figure-Four), groin (Butterfly), lower back (Knee-to-Chest), and shoulders." } }, Football: { warmup: [ { phase: "Raise", duration: "5-7 min", exercises: "<b>Line Drills (20-30 yds each):</b><ul><li>Light Jog (forward/backward)</li><li>Side Shuffles</li><li>Carioca (Grapevine)</li><li>High Knees & Butt Kicks</li></ul>", rationale: "Gradually increases body temperature while introducing multi-directional movements and reinforcing proper running mechanics." }, { phase: "Activate & Mobilize", duration: "7-10 min", exercises: "<b>Dynamic Mobility (10-15 yds each):</b><ul><li>Walking Knee Hugs</li><li>Walking Lunge with Rotation</li><li>Lateral Lunges</li><li>Inchworms</li></ul><b>Activation (2 sets):</b><ul><li>Glute Bridges & Banded Lateral Walks</li></ul>", rationale: "Systematically mobilizes key joints and activates the glutes to ensure proper firing during sprinting and cutting, protecting the hamstrings from overload." }, { phase: "Potentiate", duration: "5-7 min", exercises: "<ul><li>A-Skips & B-Skips (15 yds each)</li><li>3-4 progressive sprints over 20-30 yds, building from 50% to 90% speed.</li><li>Position-Specific Drills (e.g., routes on air, backpedals).</li></ul>", rationale: "Skips reinforce sprint mechanics, progressive sprints prime the CNS for maximal velocity, and position drills rehearse exact game movements." } ], cooldown: { stage1: "5-10 minutes of light jogging and walking.", stage2: "Crucial to perform static stretches for Hamstrings, Quadriceps, Hip Flexors, and Adductors (Groin) to prevent strains." } }, Volleyball: { warmup: [ { phase: "Raise", duration: "5 min", exercises: "<ul><li>Light Jogging</li><li>Jumping Jacks</li><li>Side Shuffles</li></ul>", rationale: "A standard general warm-up to increase core temperature and prepare the cardiovascular system." }, { phase: "Activate & Mobilize", duration: "7-10 min", exercises: "<b>Mobility (1 round):</b><ul><li>Arm Circles</li><li>Thoracic Rotations</li></ul><b>Activation (2 rounds):</b><ul><li>Banded External/Internal Shoulder Rotation</li><li>Banded Y-T-W's</li><li>Glute Bridges</li></ul>", rationale: "Banded shoulder work is critical to activate the rotator cuff for the violent arm swing. Glute activation primes the primary muscles for powerful jumping." }, { phase: "Potentiate", duration: "5-7 min", exercises: "<ul><li>Pogo Jumps & Box Jumps</li><li>5-10 approach jumps without a ball.</li><li>Controlled hitting lines, progressing in intensity.</li></ul>", rationale: "Plyometrics prime the stretch-shortening cycle for jumping, while approach practice and hitting lines provide the most specific potentiation for game speed." } ], cooldown: { stage1: "5 minutes of light jogging or passing with a partner.", stage2: "Focus on static stretches for the Shoulders (Cross-Body), Chest (Doorway Pec Stretch), Quadriceps, and Calves." } }, Swimming: { warmup: [ { phase: "Raise (Dry-Land)", duration: "3-5 min", exercises: "<ul><li>Skipping or Jumping Jacks</li><li>Arm Swings (Cross-body, Overhead)</li></ul>", rationale: "A brief period of light cardio to initiate blood flow and dynamically warm the shoulder complex." }, { phase: "Activate & Mobilize (Dry-Land)", duration: "5-7 min", exercises: "<b>Activation (2 rounds):</b><ul><li>Banded External/Internal Rotation</li><li>Y-T-W's</li><li>Scapular Push-ups</li></ul>", rationale: "This phase is critical for injury prevention. Banded activation primes the rotator cuff to stabilize the shoulder joint during the high-volume, repetitive nature of swimming." }, { phase: "Potentiate (In-Water)", duration: "15-20 min", exercises: "<ul><li>200-400m easy freestyle/backstroke.</li><li>Kick Set (e.g., 4x50m)</li><li>Drill Set (e.g., 4x50m)</li><li>Build Set (e.g., 4x50m, increasing speed each rep).</li></ul>", rationale: "The in-water phase adapts the body to the environment, refines technique, and primes the neuromuscular system for the intensity of the main workout." } ], cooldown: { stage1: "200-400 meters of very easy, leisurely swimming, focusing on long strokes.", stage2: "Post-swim, perform static stretches focusing on the Lats, Chest (Pectorals), and Shoulders." } }, Climbing: { warmup: [ { phase: "Raise", duration: "5-10 min", exercises: "<ul><li>Light Cardio (Rowing, Skipping)</li><li>Large Joint Rotations: Arm Circles, Torso Twists, Leg Swings.</li></ul>", rationale: "Increase overall body temperature and lubricate the major joints that will be used extensively on the wall." }, { phase: "Activate & Mobilize", duration: "5-7 min", exercises: "<b>Activation:</b><ul><li>Banded Shoulder Pull-Aparts (2x15)</li><li>Scapular Pull-ups on Bar (2x10)</li></ul>", rationale: "Banded shoulder work activates the rotator cuff, and scapular pull-ups prime the upper back for pulling movements, promoting shoulder stability and preventing injury." }, { phase: "Potentiate", duration: "15-25 min", exercises: "<b>1. Finger Loading:</b><ul><li>2-3 sets of 7-second hangs with 3-second rests, repeated 5-6 times.</li></ul><b>2. Easy Climbing:</b><ul><li>15-20 minutes of climbing on very easy terrain.</li></ul>", rationale: "Progressive finger loading is the single most important injury prevention measure. The easy climbing phase integrates full-body movement and technique." } ], cooldown: { stage1: "5 minutes of very easy climbing on jug holds or traversing.", stage2: "Focus on stretches for the Lats, Chest, and gentle wrist/finger extensor stretches to counteract the constant gripping." } }, Biking: { warmup: [ { phase: "Activate & Mobilize (Off-Bike)", duration: "5-7 min", exercises: "<b>Activation (2 rounds):</b><ul><li>Glute Bridges (15 reps)</li><li>Clamshells (15/side)</li><li>Bird-Dog (10/side)</li></ul>", rationale: "This crucial off-bike routine addresses 'gluteal amnesia' from the riding position, ensuring proper muscle recruitment from the first pedal stroke." }, { phase: "Raise (On-Bike)", duration: "10-15 min", exercises: "<ul><li>Easy spinning at a high cadence (90-100 RPM) in a light gear.</li></ul>", rationale: "Gradually increases heart rate and muscle temperature, while the high cadence focus helps to smooth out the pedal stroke." }, { phase: "Potentiate (On-Bike)", duration: "5-10 min", exercises: "<ul><li>For Endurance Rides: 2-3 x 2-min intervals near threshold.</li><li>For Interval Rides: 3-5 x 30-sec 'spin-ups' or short, hard efforts.</li></ul>", rationale: "Primes the body for the specific demands of the main workout, whether aerobic for tempo work or neuromuscular for sprints." } ], cooldown: { stage1: "5-10 minutes of very easy spinning in a light gear.", stage2: "Perform static stretches for Quadriceps, Hamstrings, Hip Flexors, and Glutes." } }, "Running (Sprints)": { warmup: [ { phase: "Raise", duration: "5-10 min", exercises: "<ul><li>800m-1000m of light jogging.</li></ul>", rationale: "Gradually increases muscle temperature and blood flow, preparing the tissues for more dynamic work." }, { phase: "Activate & Mobilize", duration: "10-15 min", exercises: "<b>Running Drills (2x20m each):</b><ul><li>A-Skips</li><li>B-Skips</li><li>Straight Leg Bounds</li></ul>", rationale: "Running drills are non-negotiable; they break down the sprint cycle into components, reinforcing proper posture, knee drive, and foot strike." }, { phase: "Potentiate", duration: "5-10 min", exercises: "<b>Plyometrics (2 sets each):</b><ul><li>Pogo Hops (10 reps)</li><li>Box Jumps (5 reps)</li></ul><b>Accelerations:</b><ul><li>4-6 'strides' over 40-60m, building speed from 70% to 95%.</li></ul>", rationale: "Plyometrics enhance the muscles' ability to function like springs, and accelerations dial in the nervous system for maximal speed running." } ], cooldown: { stage1: "400-800 meters of very slow jogging and walking.", stage2: "Focus on holding static stretches for the Hamstrings, Hip Flexors, Quadriceps, and Glutes for 30-60 seconds each." } }, "Running (Distance)": { warmup: [ { phase: "Raise", duration: "10-15 min", exercises: "<ul><li>1-2 miles of very easy jogging.</li></ul>", rationale: "This constitutes the bulk of the warm-up, gradually raising heart rate and muscle temperature to an efficient working level." }, { phase: "Activate & Mobilize", duration: "5 min", exercises: "<b>Key Dynamic Stretches (8-10 reps/side):</b><ul><li>Leg Swings (Forward & Lateral)</li><li>Lunge and Reach</li><li>Hip Circles</li></ul>", rationale: "A brief, targeted routine to ensure the hips, hamstrings, and ankles are moving freely, establishing an efficient stride from the outset." }, { phase: "Potentiate", duration: "2-5 min", exercises: "<ul><li>Strides: 4-6 repetitions of ~100 meters at a comfortably fast pace, with jogging recovery.</li></ul>", rationale: "Strides are crucial for neuromuscular priming. They improve running economy and coordination, ensuring the legs feel responsive." } ], cooldown: { stage1: "The last half-mile to a mile of your run can be a very slow jog, followed by walking.", stage2: "Hold static stretches for the Calves, Hamstrings, Quadriceps, and Glutes." } }, "Weightlifting (Lower Body)": { warmup: [ { phase: "Raise", duration: "5 min", exercises: "<ul><li>5 minutes of light cardio on a rower or air bike.</li></ul>", rationale: "Increases total body temperature and blood flow to the large muscles of the lower body and back." }, { phase: "Activate & Mobilize", duration: "7-10 min", exercises: "<b>Activation (2 rounds):</b><ul><li>Glute Bridges (15 reps)</li><li>Banded Lateral Walks (10 steps/side)</li><li>Bird-Dog (8/side)</li></ul>", rationale: "The goblet squat pry directly opens the hips and ankles in the squat pattern. Glute activation is paramount to protect the lower back and maximize power." }, { phase: "Potentiate", duration: "10-15 min", exercises: "<b>Ramp-Up Sets of the Main Lift:</b><ul><li>Set 1: Empty Barbell x 10</li><li>Set 2: 40% of working weight x 5</li><li>Set 3: 60% of working weight x 3</li><li>Set 4: 80% of working weight x 1-2</li></ul>", rationale: "This is the most specific potentiation. The progressively heavier sets serve as neurological primers, preparing the CNS to handle the heavy working sets." } ], cooldown: { stage1: "5 minutes of walking or light cycling.", stage2: "Focus on static stretches for the Glutes (Figure-Four), Hamstrings, Quadriceps, and Hip Flexors." } }, "Weightlifting (Upper Push)": { warmup: [ { phase: "Raise", duration: "5 min", exercises: "<ul><li>5 minutes of light cardio on a rower or arm bike.</li></ul>", rationale: "Warms the upper body musculature and shoulder joints." }, { phase: "Activate & Mobilize", duration: "7-10 min", exercises: "<b>Activation (2 rounds):</b><ul><li>Band Pull-Aparts (15 reps)</li><li>Face Pulls (15 reps)</li><li>Scapular Push-ups (15 reps)</li></ul>", rationale: "Activating the upper back is essential for creating a stable shelf for pressing, which protects the shoulder joint." }, { phase: "Potentiate", duration: "10-15 min", exercises: "<b>Ramp-Up Sets of the Main Lift:</b><ul><li>Set 1: Empty Barbell x 15</li><li>Set 2: 50% of working weight x 5</li><li>Set 3: 70% of working weight x 3</li><li>Set 4: 90% of working weight x 1</li></ul>", rationale: "Progressive loading rehearses the specific pressing pattern and potentiates the nervous system for maximal force production." } ], cooldown: { stage1: "5 minutes of light arm biking or walking.", stage2: "Use a doorway to perform a static Pec Stretch, and also stretch the Shoulders and Lats." } }, "Weightlifting (Upper Pull)": { warmup: [ { phase: "Raise", duration: "5 min", exercises: "<ul><li>5 minutes of light to moderate rowing.</li></ul>", rationale: "The rowing machine is the ideal warm-up as it involves a horizontal pulling motion, directly preparing the muscles and joints." }, { phase: "Activate & Mobilize", duration: "5-7 min", exercises: "<b>Activation (2 rounds):</b><ul><li>Scapular Pull-ups or Scapular Rows (10 reps)</li><li>Banded Straight-Arm Pulldowns (15 reps)</li><li>Face Pulls (15 reps)</li></ul>", rationale: "Scapular drills establish a strong mind-muscle connection with the back. Pulldowns isolate the lats, ensuring they initiate the pull rather than the arms." }, { phase: "Potentiate", duration: "5-10 min", exercises: "<ul><li>For Rows: 2-3 light sets focusing on squeezing shoulder blades.</li><li>For Pull-ups: 2-3 sets of a lighter variation (e.g., band-assisted).</li></ul>", rationale: "Performing a less intense version of the primary movement primes the specific muscles and neural pathways that will be used in the main workout." } ], cooldown: { stage1: "3-5 minutes of light rowing.", stage2: "Hold static stretches for the Lats and Shoulders. A Knee-to-Chest stretch can help decompress the lower back." } } };
    
    const PERSONA_PRESETS = {
        'Custom': {
            difficulty: { min: 1, max: 5 },
            focus: 'Strength', numExercises: 5, maxTime: 60,
            principle: 'Standard', supersetStrategy: 'none',
            mechanics: ['all'], types: ['all'],
            equipment: ['all']
        },
        'Athlete': {
            difficulty: { min: 2, max: 5 },
            focus: 'Endurance', numExercises: 6, maxTime: 75,
            principle: 'Degressive', supersetStrategy: 'antagonist',
            mechanics: ['all'], types: ['Plyometric (Explosive)', 'Isotonic (Dynamic)', 'Dynamic Mobility', 'Isometric (Static)'],
            equipment: ['all']
        },
        'Bodybuilder': {
            difficulty: { min: 3, max: 5 },
            focus: 'Hypertrophy', numExercises: 7, maxTime: 90,
            principle: 'Pyramid', supersetStrategy: 'compound',
            mechanics: ['Isolation', 'Compound'], types: ['Isotonic (Dynamic)'],
            equipment: ["Barbell", "Bench", "Cable", "Dumbbell", "Kettlebell", "Machine", "Pull-Up Bar", "Ab Wheel", "Box", "Captain's Chair", "Cardio Machine", "Dip Bar", "Foam Roller", "Gym Ball", "Gymnastic Rings", "Hyperextension Bench", "Jump Rope", "Landmine", "Neck Harness", "Parallettes", "Plate", "Rack", "Resistance Band", "Row Machine", "Seal Row Bench", "Sled", "Suspension Trainer", "Wrist Roller"]
        },
        'Gym Lover': {
            difficulty: { min: 2, max: 4 },
            focus: 'Hypertrophy', numExercises: 6, maxTime: 60,
            principle: 'Progressive', supersetStrategy: 'none',
            mechanics: ['all'], types: ['Isotonic (Dynamic)'],
            equipment: ["Barbell", "Bench", "Cable", "Dumbbell", "Kettlebell", "Machine", "Pull-Up Bar", "Ab Wheel", "Box", "Captain's Chair", "Cardio Machine", "Dip Bar", "Foam Roller", "Gym Ball", "Gymnastic Rings", "Hyperextension Bench", "Jump Rope", "Landmine", "Neck Harness", "Parallettes", "Plate", "Rack", "Resistance Band", "Row Machine", "Seal Row Bench", "Sled", "Suspension Trainer", "Wrist Roller"]
        },
        'Minimalist': {
            difficulty: { min: 2, max: 4 },
            focus: 'Endurance', numExercises: 4, maxTime: 30,
            principle: 'Standard', supersetStrategy: 'none',
            mechanics: ['Compound'], types: ['Isotonic (Dynamic)'],
            equipment: ['Bodyweight', 'Dumbbell', 'Kettlebell', 'Resistance Band', 'Bench']
        },
        'Powerlifter': {
            difficulty: { min: 3, max: 5 },
            focus: 'Strength', numExercises: 3, maxTime: 90,
            principle: 'Progressive', supersetStrategy: 'none',
            mechanics: ['Compound'], types: ['Isotonic (Dynamic)'],
            equipment: ['Barbell', 'Bench', 'Rack', 'Plate', 'Dumbbell', 'Resistance Band', 'Landmine']
        },
        'Rehab & Prehab User': {
            difficulty: { min: 1, max: 2 },
            focus: 'Endurance', numExercises: 5, maxTime: 45,
            principle: 'Standard', supersetStrategy: 'none',
            mechanics: ['Isolation', 'Corrective'], types: ['Isometric (Static)', 'Dynamic Mobility'],
            equipment: ["all"]
        },
        'Senior': {
            difficulty: { min: 1, max: 2 },
            focus: 'Endurance', numExercises: 5, maxTime: 45,
            principle: 'Standard', supersetStrategy: 'none',
            mechanics: ['all'], types: ['Dynamic Mobility', 'Isotonic (Dynamic)'],
            equipment: ['Bodyweight', 'Resistance Band', 'Machine', 'Cardio Machine', 'Dumbbell', 'Gym Ball']
        },
        'Street Workout Athlete': {
            difficulty: { min: 2, max: 5 },
            focus: 'Endurance', numExercises: 6, maxTime: 75,
            principle: 'Standard', supersetStrategy: 'antagonist',
            mechanics: ['all'], types: ['Isotonic (Dynamic)', 'Isometric (Static)'],
            equipment: ['Pull-Up Bar', 'Bodyweight', "Captain's Chair", 'Dip Bar', 'Gymnastic Rings', 'Parallettes', 'Resistance Band']
        },
        'Toning & Conditioning': {
            difficulty: { min: 2, max: 3 },
            focus: 'Endurance', numExercises: 7, maxTime: 50,
            principle: 'Standard', supersetStrategy: 'antagonist',
            mechanics: ['all'], types: ['all'],
            equipment: ['all']
        }
    };

    let USER_SUBSCRIPTION_STATUS = { isPro: false, status: null };

    async function waitForSubscriptionActivation(checkSubscriptionStatus, invalidateSubscriptionCache) {
        const maxAttempts = 10;
        const delayMs = 2000;

        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            console.log(`Checking subscription status (attempt ${attempt}/${maxAttempts})...`);

            invalidateSubscriptionCache();
            const status = await checkSubscriptionStatus();

            if (status.isPro) {
                console.log('Subscription activated successfully!');
                showSuccessMessage('Subscription activated! Welcome to Pro.');
                return true;
            }

            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }
        }

        console.log('Subscription not yet active. Please refresh the page in a moment.');
        showWarningMessage('Subscription processing may take a moment. Please refresh the page.');
        return false;
    }

    function showProcessingMessage(message) {
        const existing = document.getElementById('processing-overlay');
        if (existing) existing.remove();

        const overlay = document.createElement('div');
        overlay.id = 'processing-overlay';
        overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';

        const box = document.createElement('div');
        box.style.cssText = 'background:#fff;padding:2rem;border-radius:8px;text-align:center;max-width:400px;';

        const spinner = document.createElement('div');
        spinner.style.cssText = 'border:4px solid #f3f3f3;border-top:4px solid #3498db;border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite;margin:0 auto 1rem;';

        const text = document.createElement('p');
        text.textContent = message;
        text.style.cssText = 'margin:0;font-size:1.1rem;color:#333;';

        box.appendChild(spinner);
        box.appendChild(text);
        overlay.appendChild(box);
        document.body.appendChild(overlay);

        const style = document.createElement('style');
        style.textContent = '@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }';
        document.head.appendChild(style);
    }

    function hideProcessingMessage() {
        const overlay = document.getElementById('processing-overlay');
        if (overlay) overlay.remove();
    }

    function showSuccessMessage(message) {
        hideProcessingMessage();
        alert(message);
    }

    function showWarningMessage(message) {
        hideProcessingMessage();
        alert(message);
    }

    async function setupPremiumFeatures() {
        const { checkSubscriptionStatus, redirectToCheckout, invalidateSubscriptionCache, cancelSubscription } = await import('./js/subscription-service.js');

        const urlParams = new URLSearchParams(window.location.search);
        const checkoutStatus = urlParams.get('checkout');

        if (checkoutStatus === 'success') {
            invalidateSubscriptionCache();
            const cleanUrl = window.location.origin + window.location.pathname;
            window.history.replaceState({}, document.title, cleanUrl);

            showProcessingMessage('Processing your subscription... Please wait a moment.');

            await waitForSubscriptionActivation(checkSubscriptionStatus, invalidateSubscriptionCache);

            hideProcessingMessage();
        }

        try {
            USER_SUBSCRIPTION_STATUS = await checkSubscriptionStatus();

            const goProBtn = document.getElementById('go-pro-btn');
            const proBadge = document.getElementById('condition-pro-badge');
            const manageSubBtn = document.getElementById('manage-subscription-btn');

            if (USER_SUBSCRIPTION_STATUS.isPro) {
                goProBtn?.classList.add('hidden');
                proBadge?.classList.add('hidden');
                manageSubBtn?.classList.remove('hidden');
                console.log('Pro features enabled');
            } else {
                goProBtn?.classList.remove('hidden');
                proBadge?.classList.remove('hidden');
                manageSubBtn?.classList.add('hidden');
            }

            goProBtn?.addEventListener('click', showPremiumModal);
            manageSubBtn?.addEventListener('click', () => showSubscriptionModal(USER_SUBSCRIPTION_STATUS));

            document.getElementById('close-premium-modal')?.addEventListener('click', hidePremiumModal);
            document.getElementById('premium-upgrade-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'premium-upgrade-modal') hidePremiumModal();
            });

            document.getElementById('close-subscription-modal')?.addEventListener('click', hideSubscriptionModal);
            document.getElementById('subscription-management-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'subscription-management-modal') hideSubscriptionModal();
            });

            document.getElementById('cancel-subscription-btn')?.addEventListener('click', async () => {
                if (!confirm('Are you sure you want to cancel your subscription? You will retain access until the end of your billing period.')) {
                    return;
                }

                const cancelBtn = document.getElementById('cancel-subscription-btn');
                const originalText = cancelBtn.textContent;
                cancelBtn.textContent = 'Canceling...';
                cancelBtn.disabled = true;

                try {
                    const result = await cancelSubscription();

                    USER_SUBSCRIPTION_STATUS = await checkSubscriptionStatus();
                    updateSubscriptionModalUI(USER_SUBSCRIPTION_STATUS);

                    alert(result.message || 'Subscription canceled successfully.');
                } catch (error) {
                    console.error('Cancel failed:', error);
                    alert(error.message || 'Failed to cancel subscription. Please try again.');
                    cancelBtn.textContent = originalText;
                    cancelBtn.disabled = false;
                }
            });

            document.getElementById('upgrade-to-pro-btn')?.addEventListener('click', async () => {
                try {
                    document.getElementById('upgrade-to-pro-btn').textContent = 'Redirecting...';

                    const stripePriceId = 'price_1SpGBu5LRfWoxTP5ShdqxptF';

                    await redirectToCheckout(stripePriceId);
                } catch (error) {
                    console.error('Upgrade failed:', error);
                    alert(error.message || 'Failed to start checkout. Please try again.');
                    document.getElementById('upgrade-to-pro-btn').textContent = 'Upgrade Now';
                }
            });
        } catch (error) {
            console.error('Error setting up premium features:', error);
        }
    }

    function showPremiumModal() {
        const modal = document.getElementById('premium-upgrade-modal');
        if (modal) {
            modal.classList.remove('hidden');
        }
    }

    function hidePremiumModal() {
        const modal = document.getElementById('premium-upgrade-modal');
        if (modal) {
            modal.classList.add('hidden');
        }
    }

    function showSubscriptionModal(subscriptionStatus) {
        updateSubscriptionModalUI(subscriptionStatus);
        const modal = document.getElementById('subscription-management-modal');
        if (modal) {
            modal.classList.remove('hidden');
        }
    }

    function hideSubscriptionModal() {
        const modal = document.getElementById('subscription-management-modal');
        if (modal) {
            modal.classList.add('hidden');
        }
    }

    function updateSubscriptionModalUI(subscriptionStatus) {
        const statusText = document.getElementById('subscription-status-text');
        const periodEndEl = document.getElementById('subscription-period-end');
        const cancellationNotice = document.getElementById('cancellation-notice');
        const cancelSection = document.getElementById('cancel-subscription-section');
        const canceledSection = document.getElementById('subscription-canceled-section');
        const cancelEndDate = document.getElementById('cancel-end-date');

        if (subscriptionStatus.currentPeriodEnd) {
            const endDate = new Date(subscriptionStatus.currentPeriodEnd * 1000);
            const formattedDate = endDate.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
            periodEndEl.textContent = formattedDate;
            cancelEndDate.textContent = formattedDate;
        }

        if (subscriptionStatus.cancelAtPeriodEnd) {
            statusText.textContent = 'Canceling';
            statusText.classList.remove('text-green-400');
            statusText.classList.add('text-yellow-400');
            cancellationNotice?.classList.remove('hidden');
            cancelSection?.classList.add('hidden');
            canceledSection?.classList.remove('hidden');
        } else {
            statusText.textContent = 'Active';
            statusText.classList.remove('text-yellow-400');
            statusText.classList.add('text-green-400');
            cancellationNotice?.classList.add('hidden');
            cancelSection?.classList.remove('hidden');
            canceledSection?.classList.add('hidden');

            const cancelBtn = document.getElementById('cancel-subscription-btn');
            if (cancelBtn) {
                cancelBtn.textContent = 'Cancel Subscription';
                cancelBtn.disabled = false;
            }
        }
    }

    const FALLBACK_PERSONA_CONFIGS = {
        'Custom': { name: 'Custom', description: 'Full control over all settings', coachingTone: 'neutral', presets: {} },
        'Gym Lover': { name: 'Gym Lover', description: 'Balanced all-around fitness', coachingTone: 'enthusiastic', presets: { focus: 'Hypertrophy', numExercises: 6, maxTime: 75, trainingPrinciple: 'Standard', supersetStrategy: 'None', difficultyRange: { min: 2, max: 4 }, mechanics: ['Compound', 'Isolation'], types: ['Isotonic (Dynamic)'] } },
        'Bodybuilder': { name: 'Bodybuilder', description: 'Muscle growth focus', coachingTone: 'hypertrophy-focused', presets: { focus: 'Hypertrophy', numExercises: 7, maxTime: 90, trainingPrinciple: 'Pyramid', difficultyRange: { min: 2, max: 5 }, mechanics: ['Compound', 'Isolation'], types: ['Isotonic (Dynamic)'] } },
        'Powerlifter': { name: 'Powerlifter', description: 'Maximum strength', coachingTone: 'strength-focused', presets: { focus: 'Strength', numExercises: 5, maxTime: 120, trainingPrinciple: 'Progressive', difficultyRange: { min: 3, max: 5 }, mechanics: ['Compound'], types: ['Isotonic (Dynamic)'] } },
        'Minimalist': { name: 'Minimalist', description: 'Efficient, short workouts', coachingTone: 'efficiency-focused', presets: { focus: 'Hypertrophy', numExercises: 4, maxTime: 30, trainingPrinciple: 'Standard', difficultyRange: { min: 2, max: 4 }, mechanics: ['Compound'], types: ['Isotonic (Dynamic)'], preferredEquipment: ['Bodyweight', 'Dumbbell'] } },
        'Athlete': { name: 'Athlete', description: 'Sport-specific training', coachingTone: 'performance-focused', presets: { focus: 'Hypertrophy', numExercises: 6, maxTime: 60, trainingPrinciple: 'Standard', difficultyRange: { min: 2, max: 5 }, mechanics: ['Compound', 'Isolation'], types: ['Isotonic (Dynamic)', 'Plyometric (Explosive)'] } }
    };

    function fallbackApplyPersonaPresets(persona) {
        const config = FALLBACK_PERSONA_CONFIGS[persona];
        if (!config || persona === 'Custom') return null;
        return config.presets;
    }

    async function waitForPersonaConfigsReady() {
        const maxAttempts = 30;
        for (let i = 0; i < maxAttempts; i++) {
            if (window.PERSONA_CONFIGS && window.applyPersonaPresets) {
                return true;
            }
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        window.PERSONA_CONFIGS = FALLBACK_PERSONA_CONFIGS;
        window.applyPersonaPresets = fallbackApplyPersonaPresets;
        return true;
    }

    document.addEventListener('DOMContentLoaded', initializeApp);

    async function initializeApp() {
        try {
            buildStaticUI();

            document.getElementById('generate-btn').addEventListener('click', runGenerator);
            document.getElementById('generate-warmup-btn').addEventListener('click', generateWarmupCooldown);

            const resultsContainer = document.getElementById('workout-results');
            resultsContainer.addEventListener('click', handleResultsClick);
            resultsContainer.addEventListener('toggle', (event) => {
                if (event.target.tagName === 'DETAILS' && event.target.open) {
                    const explanation = event.target.dataset.aiExplanation;
                    if (explanation) {
                        const messages = splitExplanationIntoMessages(explanation, 'lightsmile');
                        if (messages.length > 0) {
                            aiGuide.sequence(messages);
                        }
                    }
                }
            }, true);


            setupPrincipleInfoPopup();
            setupSubTabs();
            setupMainTabs();
            initializeWarmupGuide();
            setupTimer();
            setupPremiumFeatures();

            await waitForPersonaConfigsReady();

            fetch('exercises.json')
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status} ${response.statusText}`);
                    return response.json();
                })
                .then(data => {
                    handleServerResponse({ data: data, error: null });
                })
                .catch(error => {
                    onDataLoadFailure({ message: `Failed to load exercises. ${error.message}` });
                });
        } catch (err) {
            console.error('initializeApp error:', err);
        }
    }

    function splitExplanationIntoMessages(text, defaultExpression = 'lightsmile') {
        if (!text || typeof text !== 'string') {
            return [];
        }
        const sentences = text.match(/[^.!?]+[.!?]*/g) || [];
        return sentences.map(sentence => ({
            text: sentence.trim(),
            expression: defaultExpression 
        })).filter(msg => msg.text.length > 0);
    }
    
    function getWorkouts() {
        return JSON.parse(localStorage.getItem('strivusWorkouts')) || [];
    }
    
    function getPRs() {
        return JSON.parse(localStorage.getItem('strivusPRs')) || {};
    }
    
    
    
    function updatePersonalRecords(session) {
        const allPRs = getPRs();
        session.exercises.forEach(ex => {
            if (!allPRs[ex.exerciseId]) allPRs[ex.exerciseId] = {};
            const exercisePRs = allPRs[ex.exerciseId];
            ex.sets.forEach(set => {
                const e1RM = calculateE1RM(set.weight, set.reps);
                if (e1RM && (!exercisePRs.oneRM || e1RM > exercisePRs.oneRM.value)) {
                    exercisePRs.oneRM = { value: e1RM, date: session.date };
                }
                let category = null;
                if (set.reps >= 2 && set.reps <= 6) category = 'strength';
                else if (set.reps >= 7 && set.reps <= 14) category = 'hypertrophy';
                else if (set.reps >= 15) category = 'endurance';
                if (category && (!exercisePRs[category] || set.weight > exercisePRs[category].weight)) {
                    exercisePRs[category] = { weight: set.weight, reps: set.reps, date: session.date };
                }
            });
        });
        localStorage.setItem('strivusPRs', JSON.stringify(allPRs));
    }

    function calculateE1RM(weight, reps) {
        if (!weight || !reps || reps < 1 || reps > 12) return null;
        return weight / (1.0278 - 0.0278 * reps);
    }
    
    function displayPersonalRecords(exerciseId, prContainer) {
        const allPRs = getPRs();
        const prs = allPRs[exerciseId] || {};
        const twoWeeksAgo = new Date();
        twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);
        const categories = {
            '1RM': { label: 'e1RM', data: prs.oneRM, format: val => `${val.toFixed(1)} kg` },
            'Strength (2-6)': { label: 'Strength', data: prs.strength, format: val => `${val.weight} kg x ${val.reps}` },
            'Hypertrophy (7-14)': { label: 'Hypertrophy', data: prs.hypertrophy, format: val => `${val.weight} kg x ${val.reps}` },
            'Endurance (15+)': { label: 'Endurance', data: prs.endurance, format: val => `${val.weight} kg x ${val.reps}` },
        };
        let html = '';
        const gridContainer = prContainer.querySelector('.grid');
        if (gridContainer) {
            Object.keys(categories).forEach(key => {
                const { label, data, format } = categories[key];
                const allTimeBest = data ? format(label === 'e1RM' ? data.value : data) : 'N/A';
                const recentBest = data && new Date(data.date) >= twoWeeksAgo ? allTimeBest : 'N/A';
                html += `<div class="bg-slate-900/70 p-2 rounded"><p class="font-semibold text-slate-300">${label}</p><p class="text-xs text-slate-400">All-Time: <span class="text-white font-medium">${allTimeBest}</span></p><p class="text-xs text-slate-500">Last 2 wks: <span class="text-slate-300 font-medium">${recentBest}</span></p></div>`;
            });
            gridContainer.innerHTML = html;
        }
    }


    function renderPerformanceGraph(exerciseId, canvas) {
        const allWorkouts = getWorkouts();
        const exerciseHistory = [];

        allWorkouts.forEach(session => {
            (session.exercises || []).forEach(ex => {
                if (ex.exerciseId == exerciseId) {
                    const weights = (ex.sets || []).map(s => parseFloat(s.weight) || 0);
                    const maxWeight = weights.length ? Math.max(...weights) : 0;
                    const totalVolume = ex.sets.reduce((sum, s) => sum + (s.reps || 0) * (s.weight || 0), 0);
                    exerciseHistory.push({
                        date: session.date,
                        maxWeight: maxWeight,
                        volume: totalVolume
                    });
                }
            });
        });

        const recentHistory = exerciseHistory.sort((a,b) => new Date(a.date) - new Date(b.date)).slice(-5);
        
        if (activeCharts[exerciseId]) {
            activeCharts[exerciseId].destroy();
        }

        if (recentHistory.length < 2) {
            const ctx = canvas.getContext('2d');
            ctx.font = "14px Inter";
            ctx.fillStyle = "#64748b";
            ctx.textAlign = "center";
            ctx.fillText("Log this exercise more to see your progress graph!", canvas.width / 2, canvas.height / 2);
            return;
        }

        activeCharts[exerciseId] = new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: {
                labels: recentHistory.map(h => new Date(h.date).toLocaleDateString()),
                datasets: [
                    {
                        label: 'Max Weight (kg)',
                        data: recentHistory.map(h => h.maxWeight),
                        borderColor: '#02B2FC',
                        backgroundColor: 'rgba(2, 178, 252, 0.1)',
                        fill: true,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Total Volume (kg)',
                        data: recentHistory.map(h => h.volume),
                        borderColor: '#02FCC9',
                        backgroundColor: 'rgba(2, 252, 201, 0.1)',
                        fill: true,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                scales: {
                    x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
                    y: { type: 'linear', display: true, position: 'left', ticks: { color: '#02B2FC' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
                    y1: { type: 'linear', display: true, position: 'right', ticks: { color: '#02FCC9' }, grid: { drawOnChartArea: false } }
                },
                plugins: { legend: { labels: { color: '#e2e8f0' } } }
            }
        });
    }

    function initializeRecordTab() {
        const addExerciseBtn = document.getElementById('add-activity-btn');
        const modalOverlay = document.getElementById('exercise-modal-overlay');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const exerciseSearch = document.getElementById('exercise-search');
        const exerciseList = document.getElementById('exercise-list');
        const logContainer = document.getElementById('workout-log-container');
        const dateInput = document.getElementById('workout-date');
        const saveBtn = document.getElementById('save-workout-btn');
        const intensitySlider = document.getElementById('intensity-slider');
        const intensityValue = document.getElementById('intensity-value');
        const activityTypeSelect = document.getElementById('activity-type');
        
        const sportSessionTemplate = document.getElementById('sport-session-template');
        const SPORT_ACTIVITIES = ['Running', 'Biking', 'Swimming', 'Jiu-Jitsu', 'Bouldering', 'Volleyball'];


        if (activityTypeSelect) {
            activityTypeSelect.innerHTML = `<option value="Strength Training">Strength Training</option>` + 
                                           SPORT_ACTIVITIES.map(sport => `<option value="${sport}">${sport}</option>`).join('');
        }

        if(dateInput) dateInput.value = new Date().toISOString().split('T')[0];
        
        if(addExerciseBtn) {
            addExerciseBtn.addEventListener('click', () => {
                const selectedActivity = activityTypeSelect.value;
                if (selectedActivity === 'Strength Training') {
                    modalOverlay.classList.remove('hidden');
                } else {
                    addSportToLog(selectedActivity);
                }
            });
        }
        
        if(closeModalBtn) closeModalBtn.addEventListener('click', () => modalOverlay.classList.add('hidden'));
        if(modalOverlay) modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) modalOverlay.classList.add('hidden'); });
        
        if(exerciseSearch) exerciseSearch.addEventListener('input', () => {
            const searchTerm = exerciseSearch.value.toLowerCase();
            const filtered = ALL_EXERCISES.filter(ex => ex.Exercise_Name.toLowerCase().includes(searchTerm));
            populateExerciseList(filtered);
        });

        if(intensitySlider) intensitySlider.addEventListener('input', () => intensityValue.textContent = intensitySlider.value);
        if(saveBtn) saveBtn.addEventListener('click', saveWorkout);

        function populateExerciseList(exercises) {
            if(!exerciseList) return;
            exerciseList.innerHTML = '';
            exercises.sort((a,b) => a.Exercise_Name.localeCompare(b.Exercise_Name)).forEach(ex => {
                const btn = document.createElement('button');
                btn.className = 'w-full text-left p-3 rounded-lg hover:bg-slate-700 transition';
                btn.textContent = ex.Exercise_Name;
                btn.dataset.exerciseId = ex.id;
                btn.addEventListener('click', () => {
                    addExerciseToLog(ex.id);
                    modalOverlay.classList.add('hidden');
                    exerciseSearch.value = '';
                    populateExerciseList(ALL_EXERCISES);
                });
                exerciseList.appendChild(btn);
            });
        }
        
        function addSportToLog(sportName) {
            const card = sportSessionTemplate.content.cloneNode(true).firstElementChild;
            card.dataset.activityName = sportName;
            card.querySelector('.activity-name').textContent = sportName;
            logContainer.appendChild(card);
        }
        
        const getWorkouts = () => JSON.parse(localStorage.getItem('strivusWorkouts')) || [];
        const getPRs = () => JSON.parse(localStorage.getItem('strivusPRs')) || {};

        function saveWorkout() {
            const date = dateInput.value;
            const intensity = intensitySlider.value;
            const notes = document.getElementById('workout-notes').value;
            const exercises = [];
            const sports = [];

            const activityCards = logContainer.querySelectorAll('.control-card');
            if (activityCards.length === 0) {
                alert("Please add at least one exercise or sport session.");
                return;
            }

            activityCards.forEach(card => {
                if (card.dataset.exerciseId) {
                    const exerciseId = card.dataset.exerciseId;
                    const exerciseName = card.querySelector('.exercise-name').textContent;
                    const sets = [];
                    card.querySelectorAll('.set-row').forEach(row => {
                        const reps = row.querySelector('.reps-input').value;
                        const time = row.querySelector('.time-input').value;
                        const weight = row.querySelector('.weight-input').value;
                        
                        if (reps || time) {
                            sets.push({
                                reps: reps ? parseInt(reps) : null,
                                time: time ? parseInt(time) : null,
                                weight: weight ? parseFloat(weight) : null
                            });
                        }
                    });
                    if (sets.length > 0) {
                        exercises.push({ exerciseId, exerciseName, sets });
                    }
                } else if (card.dataset.activityName) {
                    const activityName = card.dataset.activityName;
                    const duration = card.querySelector('.duration-input').value;
                    if (duration) {
                        sports.push({
                            name: activityName,
                            duration: parseInt(duration)
                        });
                    }
                }
            });

            const workoutSession = { date, intensity, notes, exercises, sports };

            const allWorkouts = getWorkouts();
            allWorkouts.push(workoutSession);
            localStorage.setItem('strivusWorkouts', JSON.stringify(allWorkouts));
            localStorage.removeItem('strivusConditionData');

            if (exercises.length > 0) {
                updatePersonalRecords(workoutSession);
            }

            if (window.syncWorkoutToSupabase) {
                window.syncWorkoutToSupabase(workoutSession).then(success => {
                    if (!success) {
                        console.warn('Workout saved locally but failed to sync to cloud');
                    }
                });
            }

            alert('Workout Saved!');
            logContainer.innerHTML = '';
            document.getElementById('workout-notes').value = '';
            intensitySlider.value = 5;
            intensityValue.textContent = 5;
        }


        populateExerciseList(ALL_EXERCISES);
    }
    

    function addExerciseToLog(exerciseId, prepopulatedSets = null) {
        const exerciseCardTemplate = document.getElementById('exercise-card-template');
        const logContainer = document.getElementById('workout-log-container');
        if (!exerciseCardTemplate || !logContainer) return;
    
        const exerciseData = ALL_EXERCISES.find(ex => ex.id == exerciseId);
        if (!exerciseData) return;
    
        const card = exerciseCardTemplate.content.cloneNode(true).firstElementChild;
        card.dataset.exerciseId = exerciseId;
        card.querySelector('.exercise-name').textContent = exerciseData.Exercise_Name;
    
        // Fix for delete button
        card.querySelector('.remove-card-btn').addEventListener('click', (e) => {
            e.target.closest('.control-card').remove();
        });
    
        // Populate new details section
        const detailsContainer = card.querySelector('.exercise-details-container');
        if (detailsContainer) {
            let hasDetails = false;
    
            // Populate "How to Perform"
            const howToPerformSection = card.querySelector('.how-to-perform-section');
            if (exerciseData.HowToPerform && howToPerformSection) {
                card.querySelector('.how-to-perform-text').textContent = exerciseData.HowToPerform;
                howToPerformSection.classList.remove('hidden');
                hasDetails = true;
            }
    
            // Populate "Common Errors"
            const commonErrorsSection = card.querySelector('.common-errors-section');
            if (exerciseData.CommonErrors && commonErrorsSection) {
                card.querySelector('.common-errors-text').textContent = exerciseData.CommonErrors;
                commonErrorsSection.classList.remove('hidden');
                hasDetails = true;
            }
    
            // Populate Video
            const videoSection = card.querySelector('.video-section');
            const embedUrl = getYoutubeEmbedUrl(exerciseData.video_path_gif);
            if (embedUrl && videoSection) {
                videoSection.querySelector('iframe').src = embedUrl;
                videoSection.classList.remove('hidden');
                hasDetails = true;
            }
            
            if (!hasDetails) {
                detailsContainer.classList.add('hidden');
            }
        }
    
        logContainer.appendChild(card);
    
        if (prepopulatedSets && prepopulatedSets.length > 0) {
            prepopulatedSets.forEach(set => {
                addSetToExercise(card, set.reps, set.weight);
            });
        } else {
            addSetToExercise(card);
        }
    
        card.querySelector('.add-set-btn').addEventListener('click', (e) => {
            addSetToExercise(e.target.closest('.control-card'));
        });
        
        try {
            const canvas = card.querySelector('.performance-graph');
            if (canvas) renderPerformanceGraph(exerciseId, canvas);
            
            const prDisplay = card.querySelector('.pr-display');
            if (prDisplay) displayPersonalRecords(exerciseId, prDisplay);
        } catch (error) {
            console.error("Failed to render graph or PRs for an exercise.", error);
        }
    }
    function addSetToExercise(exerciseCard, reps = '', weight = '') {
        const setRowTemplate = document.getElementById('set-row-template');
        if(!setRowTemplate) return;

        const setsContainer = exerciseCard.querySelector('.sets-container');
        const setRow = setRowTemplate.content.cloneNode(true).firstElementChild;
        const setNumber = setsContainer.children.length + 1;
        setRow.querySelector('.set-number').textContent = setNumber;

        const exerciseId = exerciseCard.dataset.exerciseId;
        const exerciseData = ALL_EXERCISES.find(ex => ex.id == exerciseId);

        const repsInput = setRow.querySelector('.reps-input');
        const timeInput = setRow.querySelector('.time-input');
        const weightInput = setRow.querySelector('.weight-input');

        repsInput.value = reps;
        weightInput.value = weight;

        if (exerciseData && exerciseData.metric === 'seconds') {
            repsInput.classList.add('hidden');
            timeInput.classList.remove('hidden');
        }

        if (exerciseData && exerciseData.Material_1 === 'Bodyweight') {
            weightInput.value = 0;
            weightInput.disabled = true;
        }

        setRow.querySelector('.delete-set-btn').addEventListener('click', (e) => {
            e.target.closest('.set-row').remove();
            const allSets = setsContainer.querySelectorAll('.set-row');
            allSets.forEach((row, index) => {
                row.querySelector('.set-number').textContent = index + 1;
            });
        });

        setsContainer.appendChild(setRow);
    }
    
    // --- CONDITION TAB: NEW IMPLEMENTATION ---

    const CONDITION_DEFAULTS = {
        acute: { N: 7, value: 0 },
        chronic: { N: 28, value: 0 },
        fatigue: { N: 7, value: 0 },
        fitness: { N: 42, value: 0 }
    };

    /**
     * Reusable EWMA calculation function.
     * @param {number} loadToday - The training load for the current day.
     * @param {number} ewmaYesterday - The EWMA value from the previous day.
     * @param {number} N - The time constant (e.g., 7 for acute, 28 for chronic).
     * @param {number} [modifier=1] - A modifier to adjust the decay of fatigue.
     * @returns {number} The new EWMA value for today.
     */
    function calculateEWMA(loadToday, ewmaYesterday, N, modifier = 1) {
        const alpha = 2 / (N + 1);
        const decayFactor = 1 - alpha;
        return (loadToday * alpha) + (ewmaYesterday * decayFactor * modifier);
    }

    /**
     * Converts daily check-in scores to a fatigue decay modifier.
     * A higher score (better recovery) results in a larger modifier, speeding up fatigue decay.
     * @param {object} checkin - { sleep, stress, nutrition }.
     * @returns {number} A modifier, e.g., between 0.8 and 1.2.
     */
    function calculateCheckinModifier(checkin) {
        if (!checkin) return 1; // Default modifier if no check-in data
        // Invert stress score (5 is good, 1 is bad)
        const stress = 6 - checkin.stress; 
        const totalScore = checkin.sleep + stress + checkin.nutrition; // Range: 3 to 15
        // Map the score from range [3, 15] to modifier range [0.8, 1.2]
        const minScore = 3, maxScore = 15;
        // REPLACE IT WITH THIS:
        const minMod = 0.8, maxMod = 1.2;
        // The 'minMod' and 'maxMod' in the formula below have been swapped to fix the logic
        const modifier = maxMod + ((totalScore - minScore) / (maxScore - minScore)) * (minMod - maxMod);
        return isNaN(modifier) ? 1 : modifier;
    }
    
    /**
     * Main function to calculate and render all condition metrics.
     */
    async function initializeConditionTab() {
        // 1. Get all raw data
        const workouts = JSON.parse(localStorage.getItem('strivusWorkouts')) || [];
        let conditionData = JSON.parse(localStorage.getItem('strivusConditionData')) || { dailyMetrics: {}, lastUpdate: null };

        // Handle first-time run: Show calibration message
        if (Object.keys(conditionData.dailyMetrics).length < 28 && workouts.length > 0) {
            const banner = document.createElement('div');
            banner.className = "control-card bg-indigo-900/50 border-indigo-500 mb-8";
            banner.innerHTML = `<h3 class="font-semibold text-white">Calibration Mode</h3><p class="text-sm text-slate-300">The model is gathering data. Insights will become more personalized over the next 28 days as you log more workouts.</p>`;
            document.querySelector('#content-condition .container').prepend(banner);
        }
        
        if (workouts.length === 0) {
            const container = document.querySelector('#content-condition .container');
            if(container) container.innerHTML = `<div class="control-card text-center"><h2 class="text-xl font-bold text-white">No Data Yet</h2><p class="text-slate-400 mt-2">Log some workouts on the 'Record Training' tab and use the 'Daily Check-in' to see your condition analysis here.</p></div>`;
            return;
        }

        // 2. Pre-process data into daily summaries
        const dailyLoads = {};
        workouts.forEach(w => {
            const date = w.date;
            if (!dailyLoads[date]) dailyLoads[date] = 0;
            let totalDuration = w.sports?.reduce((sum, s) => sum + s.duration, 0) || 0;
            if (w.exercises?.length > 0) totalDuration += 60; // Estimate 60 mins for strength
            dailyLoads[date] += (parseInt(w.intensity) * totalDuration);
        });

        // 3. Iteratively calculate daily EWMA values
        const today = new Date();
        const firstDate = new Date(workouts.sort((a, b) => new Date(a.date) - new Date(b.date))[0].date);
        let lastCalculatedDate = conditionData.lastUpdate ? new Date(conditionData.lastUpdate) : new Date(firstDate.setDate(firstDate.getDate() - 1));

        for (let d = new Date(lastCalculatedDate); d <= today; d.setDate(d.getDate() + 1)) {
            const dateStr = d.toISOString().split('T')[0];
            const yesterdayStr = new Date(d.getTime() - 86400000).toISOString().split('T')[0]; // 24 * 60 * 60 * 1000 ms
            d.setDate(d.getDate() + 1); // Correct date after modification

            const yesterdayMetrics = conditionData.dailyMetrics[yesterdayStr] || {
                acute: 0, chronic: 0, fatigue: 0, fitness: 0
            };
            
            const loadToday = dailyLoads[dateStr] || 0;
            const checkin = conditionData.dailyMetrics[dateStr]?.checkin;
            const modifier = calculateCheckinModifier(checkin);

            const acute = calculateEWMA(loadToday, yesterdayMetrics.acute, CONDITION_DEFAULTS.acute.N);
            const chronic = calculateEWMA(loadToday, yesterdayMetrics.chronic, CONDITION_DEFAULTS.chronic.N);
            const fatigue = calculateEWMA(loadToday, yesterdayMetrics.fatigue, CONDITION_DEFAULTS.fatigue.N, modifier);
            const fitness = calculateEWMA(loadToday, yesterdayMetrics.fitness, CONDITION_DEFAULTS.fitness.N);

            conditionData.dailyMetrics[dateStr] = { 
                ...conditionData.dailyMetrics[dateStr],
                load: loadToday, acute, chronic, fatigue, fitness 
            };
        }

        conditionData.lastUpdate = today.toISOString().split('T')[0];
        localStorage.setItem('strivusConditionData', JSON.stringify(conditionData));

            // 4. Call the updated model and destructure its return value
        const { acuteFatigue, chronicLoad } = await initializeMuscleFatigueModel();
        
        await setupConditionTabUI(conditionData);
    
        // 5. Pass both objects to the function that renders all UI components
        renderAllConditionComponents(conditionData, acuteFatigue, chronicLoad);
    }

        /**
             * Processes the entire workout history to calculate a daily, decaying EWMA fatigue
             * score for each individual muscle group.
             */

    async function initializeMuscleFatigueModel() {
        // --- KEY CHANGE: Define constants for easy tuning ---
        const ACUTE_N = 3;   // 3-day window for sensitive, acute fatigue
        const CHRONIC_N = 28; // 28-day window for stable, chronic load (fitness)
    
        const workouts = JSON.parse(localStorage.getItem('strivusWorkouts')) || [];
        let muscleFatigueData = JSON.parse(localStorage.getItem('strivusMuscleFatigueData')) || { dailyMetrics: {}, lastUpdate: null };
    
        if (workouts.length === 0) {
            // Return empty objects if there's no data
            return { acuteFatigue: {}, chronicLoad: {} };
        }
    
        // This part (calculating dailyMuscleLoads) remains the same
        const dailyMuscleLoads = {};
        workouts.forEach(w => {
            const date = w.date;
            if (!dailyMuscleLoads[date]) {
                dailyMuscleLoads[date] = MUSCLE_LIST.reduce((acc, m) => ({ ...acc, [m]: 0 }), {});
            }
            const rpe = parseInt(w.intensity) || 5;
            const sessionLoad = ((130 / 9) * (rpe - 1)) + 20;
            let sessionVector = new Array(MUSCLE_LIST.length).fill(0);
            (w.exercises || []).forEach(ex => {
                const exerciseData = ALL_EXERCISES.find(e => e.id == ex.exerciseId);
                if (exerciseData) {
                    exerciseData.vector.forEach((val, i) => sessionVector[i] += val);
                }
            });
            (w.sports || []).forEach(sport => {
                const sportVector = SPORT_MUSCLE_VECTORS[sport.name];
                if (sportVector) {
                    sportVector.forEach((val, i) => sessionVector[i] += val);
                }
            });
            const vectorSum = sessionVector.reduce((a, b) => a + b, 0);
            if (vectorSum > 0) {
                sessionVector = sessionVector.map(v => v / vectorSum);
            }
            sessionVector.forEach((val, i) => {
                const muscle = MUSCLE_LIST[i];
                dailyMuscleLoads[date][muscle] += sessionLoad * val;
            });
        });
    
        const today = new Date();
        const firstDate = new Date(workouts.sort((a, b) => new Date(a.date) - new Date(b.date))[0].date);
        let lastCalculatedDate = muscleFatigueData.lastUpdate ? new Date(muscleFatigueData.lastUpdate) : new Date(new Date(firstDate).setDate(firstDate.getDate() - 1));
    
        for (let d = new Date(lastCalculatedDate); d <= today; d.setDate(d.getDate() + 1)) {
            const dateStr = d.toISOString().split('T')[0];
            const yesterdayStr = new Date(d.getTime() - 86400000).toISOString().split('T')[0];
    
            // --- KEY CHANGE: Yesterday's metrics must now contain both acute and chronic values ---
            const yesterdayMetrics = muscleFatigueData.dailyMetrics[yesterdayStr] || MUSCLE_LIST.reduce((acc, m) => ({ ...acc, [m]: { acute: 0, chronic: 0 } }), {});
            const loadToday = dailyMuscleLoads[dateStr] || MUSCLE_LIST.reduce((acc, m) => ({ ...acc, [m]: 0 }), {});
    
            const todayMetrics = {};
            MUSCLE_LIST.forEach(muscle => {
                // --- KEY CHANGE: Calculate BOTH values for each muscle ---
                const acute = calculateEWMA(loadToday[muscle], yesterdayMetrics[muscle]?.acute || 0, ACUTE_N);
                const chronic = calculateEWMA(loadToday[muscle], yesterdayMetrics[muscle]?.chronic || 0, CHRONIC_N);
                todayMetrics[muscle] = { acute, chronic };
            });
            muscleFatigueData.dailyMetrics[dateStr] = todayMetrics;
        }
    
        muscleFatigueData.lastUpdate = today.toISOString().split('T')[0];
        localStorage.setItem('strivusMuscleFatigueData', JSON.stringify(muscleFatigueData));
        
        // --- KEY CHANGE: Prepare and return two separate objects for the renderer ---
        const latestMetrics = muscleFatigueData.dailyMetrics[today.toISOString().split('T')[0]] || {};
        const acuteFatigue = {};
        const chronicLoad = {};
    
        MUSCLE_LIST.forEach(muscle => {
            acuteFatigue[muscle] = latestMetrics[muscle]?.acute || 0;
            chronicLoad[muscle] = latestMetrics[muscle]?.chronic || 0;
        });
    
        return { acuteFatigue, chronicLoad };
    }

    /**
     * Populates all UI elements on the condition tab.
     */
    function renderAllConditionComponents(conditionData, acuteFatigue, chronicLoad) {
        const todayStr = new Date().toISOString().split('T')[0];
        const historicalData = Object.entries(conditionData.dailyMetrics)
            .map(([date, metrics]) => ({ date, ...metrics }))
            .sort((a, b) => new Date(a.date) - new Date(b.date))
            .slice(-42); // Show last 6 weeks
        
        const latestMetrics = conditionData.dailyMetrics[todayStr] || { acute: 0, chronic: 0, fatigue: 0, fitness: 0};
        const form = latestMetrics.fitness - latestMetrics.fatigue;
        const acwr = latestMetrics.chronic > 0 ? latestMetrics.acute / latestMetrics.chronic : 0;

        // Render components
        renderFormGauge(form, acwr);
        renderFitnessFatigueScores(latestMetrics.fitness, latestMetrics.fatigue);
        renderPerformanceTrendsChart(historicalData);
        renderAcwrChart(historicalData);
        renderCheckinHistoryChart(historicalData); 
        renderMuscleFatigue(acuteFatigue, chronicLoad);
    }
    
    /**
     * Sets up event listeners for the Daily Check-in UI.
     */
    async function setupConditionTabUI(conditionData) {
        const sliders = ['sleep', 'stress', 'nutrition'];
        sliders.forEach(s => {
            const slider = document.getElementById(`${s}-slider`);
            const valueEl = document.getElementById(`${s}-value`);
            if (slider && valueEl) {
                slider.addEventListener('input', () => {
                    valueEl.textContent = `${slider.value} / 5`;
                });
            }
        });
        
        const saveBtn = document.getElementById('save-checkin-btn');
        if (saveBtn && !saveBtn.dataset.listenerAttached) {
             saveBtn.dataset.listenerAttached = 'true';
             saveBtn.addEventListener('click', async () => {
                const todayStr = new Date().toISOString().split('T')[0];
                const checkinData = {
                    sleep: parseInt(document.getElementById('sleep-slider').value),
                    stress: parseInt(document.getElementById('stress-slider').value),
                    nutrition: parseInt(document.getElementById('nutrition-slider').value),
                    rhr: document.getElementById('rhr-input').value || null
                };

                if (!conditionData.dailyMetrics[todayStr]) {
                    conditionData.dailyMetrics[todayStr] = {};
                }
                conditionData.dailyMetrics[todayStr].checkin = checkinData;

                // Re-calculate today's metrics with the new modifier and re-render
                const yesterdayStr = new Date(new Date().setDate(new Date().getDate() - 1)).toISOString().split('T')[0];
                const yesterdayMetrics = conditionData.dailyMetrics[yesterdayStr] || { fatigue: 0, fitness: 0, acute: 0, chronic: 0 };
                const loadToday = conditionData.dailyMetrics[todayStr].load || 0;

                const modifier = calculateCheckinModifier(checkinData);
                conditionData.dailyMetrics[todayStr].fatigue = calculateEWMA(loadToday, yesterdayMetrics.fatigue, CONDITION_DEFAULTS.fatigue.N, modifier);
                conditionData.dailyMetrics[todayStr].fitness = calculateEWMA(loadToday, yesterdayMetrics.fitness, CONDITION_DEFAULTS.fitness.N);
                conditionData.dailyMetrics[todayStr].acute = calculateEWMA(loadToday, yesterdayMetrics.acute, CONDITION_DEFAULTS.acute.N);
                conditionData.dailyMetrics[todayStr].chronic = calculateEWMA(loadToday, yesterdayMetrics.chronic, CONDITION_DEFAULTS.chronic.N);

                localStorage.setItem('strivusConditionData', JSON.stringify(conditionData));

                if (window.syncCheckInToSupabase) {
                    window.syncCheckInToSupabase(checkinData, todayStr).then(success => {
                        if (!success) {
                            console.warn('Check-in saved locally but failed to sync to cloud');
                        }
                    });
                }

                const { acuteFatigue, chronicLoad } = await initializeMuscleFatigueModel();
                renderAllConditionComponents(conditionData, acuteFatigue, chronicLoad);

                alert("Check-in saved! Your readiness has been updated.");
             });
        }
    }

    function renderFormGauge(form, acwr) {
        const gaugeFill = document.getElementById('readiness-gauge-fill');
        const gaugeValue = document.getElementById('readiness-gauge-value');
        const statusEl = document.getElementById('form-status');
        if (!gaugeFill || !gaugeValue || !statusEl) return;

        const safeForm = form || 0;
        const safeAcwr = acwr || 0;

        // Normalize form score to a percentage (e.g., -100 to 100 becomes 0-100%)
        const formPercent = Math.max(0, Math.min(100, (safeForm + 100) / 2));
        
        let statusText = '';
        let color = '#02B2FC'; // Default blue

        if (safeForm > 15) { statusText = "Peaking. Ready for a peak performance."; color = '#22c55e'; }
        else if (safeForm > -5) { statusText = "Productive. Building fitness effectively."; color = '#6366f1'; }
        else if (safeForm > -20) { statusText = "Transitional. Fatigue is high, recovery is key."; color = '#f59e0b'; }
        else { statusText = "Overreaching. High fatigue, performance may suffer."; color = '#ef4444'; }

        // Override color if ACWR is in a high-risk zone, providing context
        if (safeAcwr > 1.5) {
            color = '#ef4444';
            statusText += " High injury risk detected from load jump.";
        } else if (safeAcwr > 1.3) {
            color = '#f59e0b';
        }

        gaugeFill.style.transform = `rotate(${formPercent * 1.8}deg)`;
        gaugeFill.style.borderColor = color;
        gaugeValue.textContent = `${safeForm > 0 ? '+' : ''}${safeForm.toFixed(0)}`;
        statusEl.textContent = statusText;
    }

    function renderFitnessFatigueScores(fitness, fatigue) {
        const fitnessScoreEl = document.getElementById('fitness-score');
        const fatigueScoreEl = document.getElementById('fatigue-score');
        const fitnessBar = document.getElementById('fitness-bar');
        const fatigueBar = document.getElementById('fatigue-bar');
        if(!fitnessScoreEl || !fatigueScoreEl) return;

        const safeFitness = fitness || 0;
        const safeFatigue = fatigue || 0;

        fitnessScoreEl.textContent = safeFitness.toFixed(0);
        fatigueScoreEl.textContent = safeFatigue.toFixed(0);

        // Normalize based on a reasonable max (e.g., 500)
        fitnessBar.style.width = `${Math.min(100, (safeFitness / 500) * 100)}%`;
        fatigueBar.style.width = `${Math.min(100, (safeFatigue / 500) * 100)}%`;
    }
    
    function renderPerformanceTrendsChart(historicalData) {
        const canvas = document.getElementById('performance-trends-chart');
        if (!canvas) return;
        
        if (performanceTrendsChart) performanceTrendsChart.destroy();
        
        performanceTrendsChart = new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: {
                labels: historicalData.map(d => new Date(d.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })),
                datasets: [
                    {
                        label: 'Fitness',
                        data: historicalData.map(d => d.fitness),
                        borderColor: '#0235FC',
                        tension: 0.3,
                    },
                    {
                        label: 'Fatigue',
                        data: historicalData.map(d => d.fatigue),
                        borderColor: '#ef4444',
                        tension: 0.3,
                    },
                    {
                        label: 'Form',
                        data: historicalData.map(d => d.fitness - d.fatigue),
                        borderColor: '#e2e8f0',
                        backgroundColor: 'rgba(226, 232, 240, 0.1)',
                        fill: true,
                        tension: 0.3,
                    }
                ]
            },
            options: {
                scales: {
                    y: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
                    x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }
                },
                plugins: { legend: { labels: { color: '#e2e8f0' } } }
            }
        });
    }
    
    function renderAcwrChart(historicalData) {
        const canvas = document.getElementById('acwr-chart');
        if (!canvas) return;
        
        const acwrData = historicalData.map(d => ({
            date: d.date,
            ratio: d.chronic > 0 ? d.acute / d.chronic : 0
        }));

        if (acwrChart) acwrChart.destroy();

        acwrChart = new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: {
                labels: acwrData.map(d => new Date(d.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })),
                datasets: [{
                    label: 'ACWR (EWMA)',
                    data: acwrData.map(d => d.ratio),
                    borderColor: '#02B2FC',
                    backgroundColor: 'rgba(2, 178, 252, 0.1)',
                    fill: true,
                    tension: 0.3,
                }]
            },
            options: {
                scales: {
                    y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
                    x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }
                },
                plugins: {
                    legend: { display: false },
                    annotation: {
                        annotations: {
                            sweetSpot: { type: 'box', yMin: 0.8, yMax: 1.3, backgroundColor: 'rgba(34, 197, 94, 0.1)', borderColor: 'rgba(34, 197, 94, 0.3)'}
                        }
                    }
                }
            }
        });
        const statusEl = document.getElementById('acwr-status');
        if(statusEl && acwrData.length > 0) {
            statusEl.textContent = `Current Ratio: ${acwrData[acwrData.length-1].ratio.toFixed(2)}. The optimal range (green) is 0.8 to 1.3.`;
        } else if(statusEl) {
            statusEl.textContent = 'No ACWR data yet. Start logging workouts to track your training load ratio.';
        }
    }

    function renderCheckinHistoryChart(historicalData) {
            const canvas = document.getElementById('checkin-history-chart');
            const statusEl = document.getElementById('checkin-history-status');
            if (!canvas) return;
    
            const checkinData = historicalData.filter(d => d.checkin).map(d => ({
                date: new Date(d.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                sleep: d.checkin.sleep,
                stress: d.checkin.stress, // Lower is better
                nutrition: d.checkin.nutrition
            }));
            
            if (checkinData.length < 2 && statusEl) {
                 statusEl.textContent = "Log your recovery factors for a few days to see a trend graph here.";
            }
    
            if (checkinHistoryChart) checkinHistoryChart.destroy();
            
            checkinHistoryChart = new Chart(canvas.getContext('2d'), {
                type: 'line',
                data: {
                    labels: checkinData.map(d => d.date),
                    datasets: [
                        {
                            label: 'Sleep Quality',
                            data: checkinData.map(d => d.sleep),
                            borderColor: '#38bdf8', // Light blue
                            tension: 0.3,
                        },
                        {
                            label: 'Nutrition',
                            data: checkinData.map(d => d.nutrition),
                            borderColor: '#4ade80', // Green
                            tension: 0.3,
                        },
                        {
                            label: 'Stress Level (Lower is better)',
                            data: checkinData.map(d => d.stress),
                            borderColor: '#f87171', // Red
                            tension: 0.3,
                        }
                    ]
                },
                options: {
                    scales: {
                        y: { 
                            min: 1,
                            max: 5,
                            reverse: false,
                            ticks: { 
                                color: '#94a3b8',
                                stepSize: 1
                            }, 
                            grid: { color: 'rgba(255, 255, 255, 0.1)' } 
                        },
                        x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }
                    },
                    plugins: { 
                        legend: { labels: { color: '#e2e8f0' } }
                    }
                }
            });
        }
        
    function renderMuscleFatigue(acuteFatigueScores, chronicLoadScores) {
        const muscleContainer = document.getElementById('muscle-fatigue-container');
        if (!muscleContainer) return;
    
        // Use a small minimum chronic load to avoid division by zero
        const MIN_CHRONIC_LOAD = 10; 
    
        muscleContainer.innerHTML = MUSCLE_LIST.map(muscle => {
            const acute = acuteFatigueScores[muscle] || 0;
            const chronic = Math.max(chronicLoadScores[muscle] || 0, MIN_CHRONIC_LOAD);
            
            // Normalize acute fatigue against the chronic load base
            // A score > 100% means you are more fatigued than your average fitness level
            const fatiguePercent = (acute / chronic) * 100;
    
            let barColor = 'bg-purple-500'; // Optimal
            let statusText = `Ready (${fatiguePercent.toFixed(0)}%)`;
    
            if (fatiguePercent > 130) {
                barColor = 'bg-rose-600'; // High Risk
                statusText = `High Risk (${fatiguePercent.toFixed(0)}%)`;
            } else if (fatiguePercent > 110) {
                barColor = 'bg-amber-500'; // Overreaching
                statusText = `Overreaching (${fatiguePercent.toFixed(0)}%)`;
            } else if (fatiguePercent < 80) {
                barColor = 'bg-sky-500'; // Fresh
                statusText = `Fresh (${fatiguePercent.toFixed(0)}%)`;
            }
    
            // We can show the chronic load as a background bar
            const chronicPercent = (chronic / 150) * 100; // Normalize chronic against a max for display
    
            return `
                <div>
                    <div class="flex justify-between mb-1 text-sm">
                        <span class="text-slate-300 font-semibold">${muscle}</span>
                        <span class="font-medium text-white">${statusText}</span>
                    </div>
                    <div class="w-full bg-slate-700 rounded-full h-4 relative">
                        <div class="bg-indigo-500/30 h-4 rounded-full" style="width: ${Math.min(100, chronicPercent)}%"></div>
                        <div class="${barColor} h-4 rounded-full absolute top-0" style="width: ${Math.min(100, fatiguePercent)}%"></div>
                    </div>
                </div>
            `;
        }).join('');
    }

    function setupMainTabs() {
        const tabs = {
            generator: document.getElementById('tab-generator'),
            record: document.getElementById('tab-record'),
            condition: document.getElementById('tab-condition'),
            history: document.getElementById('tab-history')
        };
        const contents = {
            generator: document.getElementById('content-generator'),
            record: document.getElementById('content-record'),
            condition: document.getElementById('content-condition'),
            history: document.getElementById('content-history')
        };

        const loadContent = async (tabName, url) => {
            const contentEl = contents[tabName];
            if (contentEl.innerHTML.trim() !== '' && tabName !== 'condition' && tabName !== 'history') { // Always re-init condition and history tabs
                return;
            };

            try {
                contentEl.innerHTML = '<p class="text-slate-500">Loading...</p>';
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load ${url}: ${response.statusText}`);
                const html = await response.text();
                contentEl.innerHTML = html;
                
                if (tabName === 'record') {
                    initializeRecordTab();
                } else if (tabName === 'condition') {
                    await initializeConditionTab();
                }
            } catch (error) {
                console.error('Error loading tab content:', error);
                contentEl.innerHTML = `<p class="text-red-400">Error loading content from ${url}. Please check the file path and ensure the server is running.</p>`;
            }
        };

        const switchTab = async (activeTabName) => {
            Object.keys(tabs).forEach(name => {
                if(tabs[name]) tabs[name].classList.toggle('active-tab', name === activeTabName);
                if(contents[name]) contents[name].classList.toggle('hidden', name !== activeTabName);
            });
            
            if (activeTabName === 'record') {
                await loadContent('record', 'record.html');
                if (WORKOUT_TO_RECORD) {
                    populateRecordTabFromData(WORKOUT_TO_RECORD);
                    WORKOUT_TO_RECORD = null;
                }
            } else if (activeTabName === 'condition') {
                await loadContent('condition', 'condition.html');
            } else if (activeTabName === 'history') {
                await loadContent('history', 'history.html');
            }
        };
        
        Object.keys(tabs).forEach(name => {
            if (tabs[name]) {
                tabs[name].addEventListener('click', () => {
                    if (name === 'condition' && !USER_SUBSCRIPTION_STATUS.isPro) {
                        showPremiumModal();
                        return;
                    }
                    switchTab(name);
                });
            }
        });

        // Setup mobile navigation
        const mobileNavButtons = document.querySelectorAll('[data-mobile-tab]');
        const mobilePageTitle = document.getElementById('mobile-page-title');
        const titleMap = {
            generator: 'Training Generator',
            record: 'Record Training',
            condition: 'Condition',
            history: 'Training History'
        };

        mobileNavButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.mobileTab;

                if (tabName === 'condition' && !USER_SUBSCRIPTION_STATUS.isPro) {
                    showPremiumModal();
                    return;
                }

                // Update mobile nav active state
                mobileNavButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                // Update mobile page title
                if (mobilePageTitle) {
                    mobilePageTitle.textContent = titleMap[tabName];
                }

                // Switch tab
                switchTab(tabName);
            });
        });
    }

    function prepareAndSwitchToRecordTab() {
        if (!CURRENT_WORKOUT_STRUCTURE || CURRENT_WORKOUT_STRUCTURE.length === 0) {
            alert("No workout has been generated to record.");
            return;
        }
        
        WORKOUT_TO_RECORD = JSON.parse(JSON.stringify(CURRENT_WORKOUT_STRUCTURE));
        document.getElementById('tab-record').click();
    }
    
    function populateRecordTabFromData(workoutData) {
        const logContainer = document.getElementById('workout-log-container');
        if (!logContainer) {
            console.error("Workout log container not found. Cannot populate from workout.");
            return;
        }
        
        logContainer.innerHTML = ''; 

        const schemas = getTrainingSchemas(LAST_PREFERENCES);
        const flatPlan = workoutData.flat();

        flatPlan.forEach(item => {
            const { exercise, sets } = item;
            const exerciseId = exercise.id;
            
            const prepopulatedSets = [];
            for (let i = 1; i <= sets; i++) {
                const repsForSet = schemas[LAST_PREFERENCES.principle](sets, i).reps;
                prepopulatedSets.push({ reps: repsForSet, weight: '' });
            }
            
            addExerciseToLog(exerciseId, prepopulatedSets);
        });
        
        const dateInput = document.getElementById('workout-date');
        if (dateInput) dateInput.value = new Date().toISOString().split('T')[0];
        logContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function setupSubTabs() {
        const tabs = document.querySelectorAll('#results-anchor .tab-btn');
        const contents = document.querySelectorAll('#results-anchor .tab-content');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active-tab'));
                contents.forEach(c => c.classList.add('hidden'));
                
                tab.classList.add('active-tab');
                const targetContentId = `content-${tab.id.split('-')[1]}`;
                document.getElementById(targetContentId).classList.remove('hidden');
            });
        });
    }

    function initializeWarmupGuide() {
        const warmupSelect = document.getElementById('warmup-select');
        const warmupDisplay = document.getElementById('warmup-display');
        const activityNames = Object.keys(WARMUP_DATA);
        
        warmupSelect.innerHTML = activityNames.map(name => `<option value="${name}">${name}</option>`).join('');

        function renderWarmup(activityName) {
            const data = WARMUP_DATA[activityName];
            if (!data) {
                warmupDisplay.innerHTML = '<p>Please select an activity.</p>';
                return;
            }

            const warmupHTML = data.warmup.map(phase => `
                <div class="warmup-card">
                    <div class="flex flex-wrap justify-between items-baseline mb-4">
                        <h3 class="text-2xl font-bold text-white">${phase.phase}</h3>
                        <span class="text-lg font-medium text-slate-400">${phase.duration}</span>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
                        <div>
                            <h4 class="font-semibold text-slate-300 mb-2">Exercises:</h4>
                            <div class="prose prose-sm prose-invert text-slate-400">${phase.exercises}</div>
                        </div>
                        <div>
                            <h4 class="font-semibold text-slate-300 mb-2">Rationale & Cues:</h4>
                            <p class="text-slate-400">${phase.rationale}</p>
                        </div>
                    </div>
                </div>
            `).join('');

            const cooldownHTML = `
                <div class="warmup-card bg-slate-900 border border-accent-blue">
                        <h3 class="text-2xl font-bold text-white mb-4">Cool-Down Protocol</h3>
                        <div>
                           <h4 class="font-semibold text-slate-300 mb-2">Stage 1: Light Aerobic Activity</h4>
                           <p class="text-slate-400 mb-4">${data.cooldown.stage1}</p>
                           <h4 class="font-semibold text-slate-300 mb-2">Stage 2: Static Stretching</h4>
                           <p class="text-slate-400">${data.cooldown.stage2}</p>
                        </div>
                </div>
            `;

            warmupDisplay.innerHTML = `
                <h2 class="text-3xl font-bold text-white mb-4 border-b border-slate-700 pb-2">Warm-Up: ${activityName}</h2>
                <div class="space-y-4">${warmupHTML}</div>
                <h2 class="text-3xl font-bold text-white mb-4 mt-8 border-b border-slate-700 pb-2">Cool-Down: ${activityName}</h2>
                ${cooldownHTML}
            `;
        }

        warmupSelect.addEventListener('change', (e) => renderWarmup(e.target.value));
        renderWarmup(activityNames[0]);
    }

    function generateWarmupCooldown() {
        const warmupDisplay = document.getElementById('warmup-display');
        warmupDisplay.innerHTML = ''; 

        const targetVector = MUSCLE_LIST.map(muscle => parseInt(document.getElementById(`${muscle}-slider`).value) || 0);
        const targetSum = targetVector.reduce((a, b) => a + b, 0);

        if (targetSum === 0) {
            warmupDisplay.innerHTML = `<p class="text-yellow-400">Please set your target muscles in Section 1 to generate a tailored warm-up and cooldown routine.</p>`;
            document.getElementById('tab-warmup').click();
            document.getElementById('results-anchor').scrollIntoView({ behavior: 'smooth' });
            return;
        }
        const normalizedTarget = targetVector.map(v => v / targetSum);

        const filterAndScore = (tagName) => {
            const exercises = ALL_EXERCISES.filter(ex => ex.tags && ex.tags.includes(tagName));
            exercises.forEach(ex => {
                const vectorSum = ex.vector.reduce((a, b) => a + b, 0);
                if (vectorSum === 0) {
                    ex.score = 0;
                    return;
                }
                const normalizedExVector = ex.vector.map(v => v / vectorSum);
                let dotProduct = 0;
                for (let i = 0; i < normalizedExVector.length; i++) {
                    dotProduct += normalizedExVector[i] * normalizedTarget[i];
                }
                ex.score = dotProduct;
            });
            return exercises.sort((a, b) => b.score - a.score);
        };

        const warmupRaiseExercises = filterAndScore("Warmup Raise");
        const warmupActivateExercises = filterAndScore("Warmup Activate & Mobilize");
        const warmupPotentiateExercises = filterAndScore("Warmup Potentiate");
        const cooldownStretchExercises = filterAndScore("Cooldown");

        const selectedRaise = warmupRaiseExercises.slice(0, 2);
        const selectedActivate = warmupActivateExercises.slice(0, 3);
        const selectedPotentiate = warmupPotentiateExercises.slice(0, 2);
        const selectedCooldownAerobic = warmupRaiseExercises.slice(0, 1);
        const selectedCooldownStretch = cooldownStretchExercises.slice(0, 4);

        const renderPhase = (title, duration, rationale, exercises) => {
            if (exercises.length === 0) return '';
            
            const exercisesHTML = exercises.map(ex => {
                const embedUrl = getYoutubeEmbedUrl(ex.video_path_gif);
                const videoHTML = embedUrl ? `<iframe src="${embedUrl}" width="100%" height="200" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen class="w-full aspect-video rounded-md mt-2"></iframe>` : '';
                return `
                    <details class="result-card bg-slate-800/50 my-2">
                        <summary class="p-3 font-medium text-slate-200 cursor-pointer hover:bg-slate-700/50 rounded-t-md">${ex.Exercise_Name}</summary>
                        <div class="px-3 pb-3 border-t border-slate-700">
                            ${ex.HowToPerform ? `<p class="text-sm text-slate-400 mt-2 whitespace-pre-wrap">${ex.HowToPerform}</p>` : ''}
                            ${videoHTML}
                        </div>
                    </details>
                `;
            }).join('');

            return `
                <div class="warmup-card">
                    <div class="flex flex-wrap justify-between items-baseline mb-4">
                        <h3 class="text-2xl font-bold text-white">${title}</h3>
                        <span class="text-lg font-medium text-slate-400">${duration}</span>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
                        <div>
                            <h4 class="font-semibold text-slate-300 mb-2">Exercises:</h4>
                            <div>${exercisesHTML}</div>
                        </div>
                        <div>
                            <h4 class="font-semibold text-slate-300 mb-2">Rationale & Cues:</h4>
                            <p class="text-slate-400">${rationale}</p>
                        </div>
                    </div>
                </div>`;
        };
        
        let html = `
            <h2 class="text-3xl font-bold text-white mb-4 border-b border-slate-700 pb-2">Generated Warm-Up Routine</h2>
            <div class="space-y-4">
                ${renderPhase('Raise', 'Approx. 6 min', 'Elevates core temperature, increases heart rate, and improves blood flow to muscles.', selectedRaise)}
                ${renderPhase('Activate & Mobilize', 'Approx. 5 min', 'Activates key stabilizing muscles and mobilizes joints through their full range of motion.', selectedActivate)}
                ${renderPhase('Potentiate', 'Approx. 3 min', 'Primes the central nervous system for more intense activity and improves the muscles\' ability to produce force rapidly.', selectedPotentiate)}
            </div>
            <h2 class="text-3xl font-bold text-white mb-4 mt-8 border-b border-slate-700 pb-2">Generated Cool-Down Routine</h2>
            <div class="space-y-4">
                ${renderPhase('Light Aerobic Activity', 'Approx. 5 min', 'Gradually lowers heart rate and begins the recovery process.', selectedCooldownAerobic)}
                ${renderPhase('Static Stretching', 'Approx. 7 min', 'Helps restore muscles to their resting length and improves flexibility.', selectedCooldownStretch)}
            </div>
        `;

        warmupDisplay.innerHTML = html;
        document.getElementById('warmup-select').classList.add('hidden');
        document.querySelector('label[for="warmup-select"]').classList.add('hidden');
        document.getElementById('tab-warmup').click();
        document.getElementById('results-anchor').scrollIntoView({ behavior: 'smooth' });
    }

    function setupPopup(popupId, openBtnId, closeBtnId, onOpen = () => {}) {
        const popup = document.getElementById(popupId);
        const openBtn = document.getElementById(openBtnId);
        const closeBtn = document.getElementById(closeBtnId);

        const show = () => {
            popup.classList.remove('hidden');
            onOpen();
        };
        const hide = () => popup.classList.add('hidden');

        if (openBtn) openBtn.addEventListener('click', show);
        if (closeBtn) closeBtn.addEventListener('click', hide);
        popup.addEventListener('click', (e) => { if (e.target === popup) hide(); });
        
        return { show, hide };
    }
    
    function setupPrincipleInfoPopup() {
        setupPopup('principle-info-popup', 'principle-info-btn', 'close-principle-info-btn');
    }
    
    function handleServerResponse(response) {
        try {
            if (!response) {
                onDataLoadFailure({ message: 'Response is null or undefined' });
                return;
            }
            if (response.error) {
                onDataLoadFailure({ message: response.error });
                return;
            }
            const exercises = response.data;
            if (!exercises || !Array.isArray(exercises)) {
                onDataLoadFailure({ message: 'Invalid exercises data format' });
                return;
            }

            ALL_EXERCISES = exercises.map(ex => {
                ex.vector = MUSCLE_LIST.map(muscle => parseFloat(ex[muscle]) || 0);
                return ex;
            });

        const equipmentSet = new Set();
        const personaSet = new Set();
        const typeSet = new Set();
        const mechanicsSet = new Set();
        const sportTagsSet = new Set();
        
        ALL_EXERCISES.forEach(ex => {
            ['Material_1', 'Material_2', 'Material_3'].forEach(mat => {
                if (ex[mat]) equipmentSet.add(String(ex[mat]).trim());
            });
            if (ex.Persona) ex.Persona.forEach(p => personaSet.add(p));
            if (ex.type) ex.type.forEach(t => typeSet.add(t));
            if (ex.mechanics) ex.mechanics.forEach(m => mechanicsSet.add(m));
            if (ex.tags && Array.isArray(ex.tags)) {
                ex.tags.forEach(tag => sportTagsSet.add(tag));
            }
            if (ex.skill_progression && ex.skill_progression.length > 0) {
                const skillName = ex.skill_progression[0];
                if (!SKILL_PROGRESSIONS[skillName]) {
                    SKILL_PROGRESSIONS[skillName] = [];
                }
                SKILL_PROGRESSIONS[skillName].push({
                    name: ex.Exercise_Name,
                    id: ex.id,
                    difficulty: ex.difficulty
                });
            }
        });

        for (const skill in SKILL_PROGRESSIONS) {
            SKILL_PROGRESSIONS[skill].sort((a, b) => a.difficulty - b.difficulty);
        }

        equipmentSet.add("Bodyweight");

        buildDynamicUI({
            equipment: Array.from(equipmentSet).sort(),
            personas: Array.from(personaSet).sort(),
            types: Array.from(typeSet).sort(),
            mechanics: Array.from(mechanicsSet).sort(),
            sportTags: Array.from(sportTagsSet).sort()
        });

        const generateBtn = document.getElementById('generate-btn');
        generateBtn.disabled = false;
        generateBtn.textContent = 'Evolve My Workout';
        document.getElementById('generate-warmup-btn').disabled = false;
        document.getElementById('status-log').textContent = `Successfully loaded ${ALL_EXERCISES.length} exercises. Ready to generate.`;
        
        applyPersonaPreset('Gym Lover');
        const gymLoverBtn = document.querySelector('input[name="persona"][value="Gym Lover"]');
        if (gymLoverBtn) {
            gymLoverBtn.checked = true;
        }
        } catch (err) {
            console.error('handleServerResponse error:', err.message);
            onDataLoadFailure({ message: `Exception in handleServerResponse: ${err.message}` });
        }
    }

    function onDataLoadFailure(error) {
        const statusLog = document.getElementById('status-log');
        statusLog.style.color = '#f87171';
        statusLog.textContent = `CRITICAL ERROR: Failed to load data from server.\n\nError Details: ${error.message}`;
        document.getElementById('generate-btn').textContent = 'Error: Reload';
    }

    function updateSliderFeedback(slider) {
        const value = parseInt(slider.value);
        const muscleName = slider.id.replace('-slider', '');
        const feedbackSpan = document.querySelector(`.dynamic-feedback[data-muscle="${muscleName}"]`);
        if (!feedbackSpan) return;

        let text, colorClass;
        if (value === 0) {
            text = "No Focus";
            colorClass = "text-slate-500";
        } else if (value < 25) {
            text = "Low Priority";
            colorClass = "text-sky-400";
        } else if (value < 50) {
            text = "Moderate Priority";
            colorClass = "text-indigo-400";
        } else if (value < 75) {
            text = "High Priority";
            colorClass = "text-purple-400";
        } else {
            text = "Primary Focus";
            colorClass = "text-fuchsia-400";
        }
        feedbackSpan.textContent = text;
        feedbackSpan.className = `dynamic-feedback text-sm font-medium ${colorClass}`;
    }
    
    function buildStaticUI() {
        const focusContainer = document.getElementById('focus-toggles');
        const focuses = ["Strength", "Hypertrophy", "Endurance"];
        focusContainer.innerHTML = focuses.map((focus, index) => `<label class="flex-1"><input type="radio" name="focus" value="${focus}" class="sr-only peer" ${index === 0 ? 'checked' : ''}><div class="text-center py-2 px-3 sm:px-4 rounded-lg cursor-pointer peer-checked:bg-action-blue peer-checked:text-white bg-slate-700 text-slate-300 text-sm sm:text-base">${focus}</div></label>`).join('');
        
        const principleContainer = document.getElementById('principle-toggles');
        const principles = ["Standard", "Progressive", "Degressive", "Pyramid"];
        principleContainer.innerHTML = principles.map((p, index) => 
            `<label class="flex-grow"><input type="radio" name="principle" value="${p}" class="sr-only peer" ${index === 0 ? 'checked' : ''}><div class="text-center py-2 px-3 sm:px-4 rounded-lg cursor-pointer peer-checked:bg-action-blue peer-checked:text-white bg-slate-700 text-slate-300 text-sm sm:text-base">${p}</div></label>`
        ).join('');

        const supersetContainer = document.getElementById('superset-toggles');
        const supersetOptions = [
            { value: 'none', label: 'None', tooltip: 'Perform one exercise at a time.' },
            { value: 'antagonist', label: 'Antagonist', tooltip: 'Pair exercises for opposing muscle groups (e.g., Chest & Back) to save time.' },
            { value: 'compound', label: 'Compound', tooltip: 'Pair two exercises for the same muscle group back-to-back to increase intensity.' }
        ];
        supersetContainer.innerHTML = supersetOptions.map((opt, index) => `
            <label class="flex-grow tooltip-container">
                 <span class="tooltip">${opt.tooltip}</span>
                 <input type="radio" name="superset" value="${opt.value}" class="sr-only peer" ${index === 0 ? 'checked' : ''}>
                 <div class="text-center py-2 px-3 sm:px-4 rounded-lg cursor-pointer peer-checked:bg-action-blue peer-checked:text-white bg-slate-700 text-slate-300 text-sm sm:text-base">${opt.label}</div>
            </label>
        `).join('');


        // Difficulty Slider Logic
        const minSlider = document.getElementById('difficulty-min');
        const maxSlider = document.getElementById('difficulty-max');
        const valueDisplay = document.getElementById('difficulty-value');
        const sliderTrack = document.querySelector('.slider-track');

        function updateDifficultyDisplay() {
            const minVal = parseInt(minSlider.value);
            const maxVal = parseInt(maxSlider.value);
            valueDisplay.textContent = `${minVal} - ${maxVal}`;
            
            const range = parseInt(maxSlider.max) - parseInt(maxSlider.min);
            const minPercent = (minVal - minSlider.min) / range * 100;
            const maxPercent = (maxVal - minSlider.min) / range * 100;
            sliderTrack.style.left = `${minPercent}%`;
            sliderTrack.style.width = `${maxPercent - minPercent}%`;
        }

        minSlider.addEventListener('input', () => {
            if (parseInt(minSlider.value) > parseInt(maxSlider.value)) {
                maxSlider.value = minSlider.value;
            }
            updateDifficultyDisplay();
        });

        maxSlider.addEventListener('input', () => {
            if (parseInt(maxSlider.value) < parseInt(minSlider.value)) {
                minSlider.value = maxSlider.value;
            }
            updateDifficultyDisplay();
        });
        updateDifficultyDisplay();
    }

    const PRESET_STORAGE_KEY = 'fitAlchemistPresets';

    function getPresets() {
        try {
            const presets = localStorage.getItem(PRESET_STORAGE_KEY);
            return presets ? JSON.parse(presets) : {};
        } catch (e) {
            console.error("Could not read presets from localStorage", e);
            return {};
        }
    }

    function savePresets(presets) {
        try {
            localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
        } catch (e) {
            console.error("Could not save presets to localStorage", e);
        }
    }

    function renderPresetOptions() {
        const presets = getPresets();
        const presetSelect = document.getElementById('preset-select');
        const presetNames = Object.keys(presets);

        if (!presetSelect) return;

        presetSelect.innerHTML = presetNames.length > 0
            ? presetNames.map(name => `<option value="${name}">${name}</option>`).join('')
            : `<option disabled>No presets saved</option>`;
        
        document.getElementById('load-preset-btn').disabled = presetNames.length === 0;
        document.getElementById('delete-preset-btn').disabled = presetNames.length === 0;
    }

    function handleSavePreset() {
        const nameInput = document.getElementById('preset-name-input');
        const name = nameInput.value.trim();
        if (!name) {
            alert('Please enter a name for the preset.');
            return;
        }

        const checkedEquipment = Array.from(document.querySelectorAll('.equipment-checkbox:checked')).map(cb => cb.value);
        
        const presets = getPresets();
        presets[name] = checkedEquipment;
        savePresets(presets);

        nameInput.value = '';
        renderPresetOptions();
        alert(`Preset '${name}' saved!`);
    }

    function handleLoadPreset() {
        const presetSelect = document.getElementById('preset-select');
        const selectedName = presetSelect.value;
        if (!selectedName) {
            alert('No preset selected.');
            return;
        }

        const presets = getPresets();
        const equipmentToSelect = presets[selectedName];

        if (equipmentToSelect) {
            const allCheckboxes = document.querySelectorAll('.equipment-checkbox');
            allCheckboxes.forEach(cb => {
                cb.checked = equipmentToSelect.includes(cb.value);
            });
        }
    }

    function handleDeletePreset() {
        const presetSelect = document.getElementById('preset-select');
        const selectedName = presetSelect.value;
        if (!selectedName) {
            alert('No preset selected to delete.');
            return;
        }

        if (confirm(`Are you sure you want to delete the preset '${selectedName}'?`)) {
            const presets = getPresets();
            delete presets[selectedName];
            savePresets(presets);
            renderPresetOptions();
        }
    }

    function buildDynamicUI(catalogs) {
        const personaContainer = document.getElementById('persona-selector');
        const personaTooltips = {
            'Custom': 'No persona filter. Considers all exercises matching your criteria.',
            'Athlete': 'Prioritizes performance, power, and speed. Function over form.',
            'Bodybuilder': 'Focuses on muscle isolation and hypertrophy for aesthetic goals.',
            'Gym Lover': 'A balanced approach for overall health, combining strength and cardiovascular fitness.',
            'Minimalist': 'Maximum results with minimum time and equipment. Ruthless efficiency.',
            'Powerlifter': 'Singular pursuit of maximal strength in squat, bench, and deadlift.',
            'Rehab & Prehab User': 'Selects the safest exercises to aid recovery and prevent future injuries.',
            'Senior': 'Low-impact routines to maintain mobility, strength, and operational integrity.',
            'Street Workout Athlete': 'Emphasizes bodyweight skills, calisthenics, and functional strength.',
            'Strongman / Strongwoman': 'Builds brute strength for lifting heavy, unconventional objects.',
            'Toning & Conditioning': 'Focus on muscular definition and metabolic resistance with higher reps.'
        };
        const personaConfigsAvailable = window.PERSONA_CONFIGS || {};
        const personas = ['Custom', ...Object.keys(personaConfigsAvailable).filter(p => p !== 'Custom').sort()];
        
        personaContainer.innerHTML = personas.map((p) => `
            <label class="persona-selector tooltip-container">
                <span class="tooltip">${personaTooltips[p] || 'A general-purpose training style.'}</span>
                <input type="radio" name="persona" value="${p}" class="sr-only">
                <div class="persona-card">
                    <span class="font-semibold text-white">${p}</span>
                </div>
            </label>
        `).join('');

        const buildCheckboxGroup = (containerId, items, groupName) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = `<label class="chip-label"><input type="checkbox" id="select-all-${groupName}"><span>All</span></label>` + 
                                  items.map(item => `<label class="chip-label"><input type="checkbox" class="${groupName}-checkbox" value="${item}"><span>${item}</span></label>`).join('');
            
            const allCheckbox = document.getElementById(`select-all-${groupName}`);
            const itemCheckboxes = container.querySelectorAll(`.${groupName}-checkbox`);
            
            allCheckbox.addEventListener('change', () => {
                itemCheckboxes.forEach(cb => cb.checked = allCheckbox.checked);
            });

            itemCheckboxes.forEach(cb => {
                cb.addEventListener('change', () => {
                    allCheckbox.checked = [...itemCheckboxes].every(item => item.checked);
                });
            });
        };

        buildCheckboxGroup('mechanics-checkboxes', catalogs.mechanics, 'mechanic');
        buildCheckboxGroup('type-checkboxes', catalogs.types, 'type');
        buildCheckboxGroup('sports-checkboxes', catalogs.sportTags, 'sport');

        // Set defaults: check all mechanics and types by default
        document.querySelectorAll('.mechanic-checkbox').forEach(cb => cb.checked = true);
        document.querySelectorAll('.type-checkbox').forEach(cb => cb.checked = true);


        const sliderContainer = document.getElementById('muscle-sliders');
        
    const muscleGroupMap = MUSCLE_LIST.reduce((acc, muscle) => {
        acc[muscle] = new Set();
        return acc;
    }, {});

    const allSpecificMuscles = new Set();
    ALL_EXERCISES.forEach(ex => {
        [...(ex.Primary_Muscles || []), ...(ex.Secondary_Muscles || [])].forEach(sm => {
            if (sm) allSpecificMuscles.add(sm.trim());
        });
    });

    allSpecificMuscles.forEach(specificMuscle => {
        const smLower = specificMuscle.toLowerCase();
        let assigned = false;
    
        for (const mainGroup of MUSCLE_LIST) {
            const mgLower = mainGroup.toLowerCase();
    
            switch (mgLower) {
                case 'chest':
                    if (smLower.includes('pectoralis') || smLower.includes('serratus')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'lats':
                    if (smLower.includes('latissimus') || smLower.includes('teres major')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'deltoids':
                    if (smLower.includes('deltoid') || smLower.includes('rotator cuff') || smLower.includes('supraspinatus')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'biceps':
                    if (smLower.includes('biceps') || smLower.includes('brachialis')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'triceps':
                    if (smLower.includes('triceps') || smLower.includes('anconeus')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'abs':
                    if (smLower.includes('abdominis') || smLower.includes('oblique') || smLower.includes('hip flexors') || smLower.includes('diaphragm')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'forearm':
                    if (smLower.includes('forearm') || smLower.includes('wrist') || smLower.includes('brachioradialis')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'quads':
                    if (smLower.includes('quadricep') || smLower.includes('adductor') || smLower.includes('tensor fasciae latae')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'hams':
                    if (smLower.includes('hamstring')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'calfs':
                    if (smLower.includes('calf') || smLower.includes('soleus') || smLower.includes('tibialis')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'glutes':
                    if (smLower.includes('glute')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'lumbar':
                    if (smLower.includes('erector spinae') || smLower.includes('quadratus lumborum')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
                case 'trapezius':
                    if (smLower.includes('trapezius') || smLower.includes('rhomboids') || smLower.includes('levator scapulae') || smLower.includes('neck muscles')) {
                        muscleGroupMap[mainGroup].add(specificMuscle);
                        assigned = true;
                    }
                    break;
            }
    
            if (assigned) break;
        }
    
        if (!assigned && specificMuscle) {
            console.warn(`Unassigned muscle: ${specificMuscle}`);
        }
    });

        sliderContainer.innerHTML = MUSCLE_LIST.map(muscle => {
            const subMuscleList = Array.from(muscleGroupMap[muscle]).sort();

            const createSubMuscleCheckbox = (subMuscle) => `
                <label class="flex items-center space-x-2 text-xs text-slate-400 cursor-pointer">
                    <input type="checkbox" value="${subMuscle}" class="specific-muscle-checkbox bg-slate-800 border-slate-600 rounded text-action-blue focus:ring-accent-blue" checked>
                    <span>${subMuscle}</span>
                </label>`;

            const subMuscleHtml = (subMuscleList.length > 0) ? `
                <details class="mt-2">
                    <summary class="text-xs text-slate-500 hover:text-action-blue">Refine ${muscle} Target...</summary>
                    <div class="pt-2 pl-2 border-l border-slate-600 grid grid-cols-1 sm:grid-cols-2 gap-1 mt-2">
                        ${subMuscleList.map(createSubMuscleCheckbox).join('')}
                    </div>
                </details>
            ` : '';

            return `
            <div class="slider-container py-3 px-2">
                <div class="flex justify-between items-center mb-2">
                    <label for="${muscle}-slider" class="font-medium text-slate-300">${muscle}</label>
                    <span class="dynamic-feedback" data-muscle="${muscle}"></span>
                </div>
                <input type="range" name="${muscle}-slider" id="${muscle}-slider" min="0" max="100" value="0" class="w-full muscle-slider">
                ${subMuscleHtml}
            </div>`
        }).join('');
        
        const allSliders = document.querySelectorAll('.muscle-slider');
        allSliders.forEach(updateSliderFeedback);
        sliderContainer.addEventListener('input', e => {
            if (e.target.classList.contains('muscle-slider')) {
                let currentTotal = 0;
                allSliders.forEach(slider => { currentTotal += parseInt(slider.value); });
                if (currentTotal > 1000) {
                    const diff = currentTotal - 1000;
                    e.target.value = Math.max(0, parseInt(e.target.value) - diff);
                }
                updateSliderFeedback(e.target);
            }
        });

        const autoBalanceBtn = document.getElementById('auto-balance-btn');
        if (autoBalanceBtn) {
            autoBalanceBtn.addEventListener('click', async () => {
                autoBalanceBtn.disabled = true;
                autoBalanceBtn.textContent = '‚è≥ Calculating...';

                try {
                    const balancedData = await window.calculateBalancedTargets();
                    if (balancedData && balancedData.targets) {
                        MUSCLE_LIST.forEach(muscle => {
                            const slider = document.getElementById(`${muscle}-slider`);
                            if (slider) {
                                slider.value = balancedData.targets[muscle] || 0;
                                updateSliderFeedback(slider);
                            }
                        });

                        const readinessIndicator = document.getElementById('readiness-indicator');
                        const readinessSummary = document.getElementById('readiness-summary');
                        if (readinessIndicator && readinessSummary && balancedData.readiness) {
                            const sortedMuscles = Object.entries(balancedData.readiness)
                                .sort((a, b) => b[1] - a[1])
                                .slice(0, 5);

                            readinessSummary.innerHTML = sortedMuscles.map(([muscle, score]) => {
                                const color = window.getReadinessColor ? window.getReadinessColor(score) : { color: '#10b981', label: 'Ready' };
                                return `<div class="flex justify-between items-center mb-1">
                                    <span>${muscle}</span>
                                    <span class="font-semibold" style="color: ${color.color}">${Math.round(score)}% - ${color.label}</span>
                                </div>`;
                            }).join('');
                            readinessIndicator.classList.remove('hidden');
                        }

                        showSuccessMessage('Workout targets balanced based on your recovery and training history!');
                    }
                } catch (error) {
                    console.error('Error calculating balanced targets:', error);
                    showWarningMessage('Using default balanced targets');
                } finally {
                    autoBalanceBtn.disabled = false;
                    autoBalanceBtn.textContent = '‚ö° Auto-Balance';
                }
            });
        }

        const skillSliderContainer = document.getElementById('skill-sliders');
        skillSliderContainer.innerHTML = Object.keys(SKILL_PROGRESSIONS).map(skillName => {
            const levels = SKILL_PROGRESSIONS[skillName];
            return `
            <div>
                 <div class="flex justify-between items-center mb-2">
                    <label for="${skillName}-skill-slider" class="font-medium text-slate-300">${skillName}</label>
                    <span id="${skillName}-skill-label" class="text-sm font-medium text-indigo-400"></span>
                </div>
                <input type="range" name="${skillName}-skill-slider" id="${skillName}-skill-slider" data-skill="${skillName}" min="0" max="${levels.length - 1}" value="0" class="w-full skill-slider">
            </div>
            `
        }).join('');

        document.querySelectorAll('.skill-slider').forEach(slider => {
            const updateLabel = () => {
                const skillName = slider.dataset.skill;
                const level = parseInt(slider.value);
                const label = document.getElementById(`${skillName}-skill-label`);
                label.textContent = SKILL_PROGRESSIONS[skillName][level].name;
            }
            slider.addEventListener('input', updateLabel);
            updateLabel();
        });
        
        const equipmentContainer = document.getElementById('equipment-checkboxes');
        const mainItems = catalogs.equipment.filter(item => MAIN_EQUIPMENT_LIST.has(item));
        const specificItems = catalogs.equipment.filter(item => !MAIN_EQUIPMENT_LIST.has(item));

        const createEquipmentCheckbox = (item) => `
            <label class="flex items-center space-x-3 text-slate-300 cursor-pointer p-2 hover:bg-slate-800 rounded-md">
                <input type="checkbox" value="${item}" class="equipment-checkbox bg-slate-700 border-slate-600 rounded text-action-blue focus:ring-accent-blue">
                <span class="flex items-center gap-2">
                    ${EQUIPMENT_ICONS[item] || EQUIPMENT_ICONS['Default']}
                    <span>${item}</span>
                </span>
            </label>`;

        const presetManagerHTML = `
            <div id="equipment-presets" class="mb-4 p-3 bg-slate-800/50 rounded-lg border border-slate-700">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="font-semibold text-white">Presets</h3>
                    <div class="flex gap-2">
                        <button id="load-preset-btn" title="Load Selected Preset" class="bg-action-blue hover:bg-action-blue-hover text-white p-2 rounded-lg disabled:bg-slate-500 disabled:cursor-not-allowed"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg></button>
                        <button id="delete-preset-btn" title="Delete Selected Preset" class="bg-red-600 hover:bg-red-700 text-white p-2 rounded-lg disabled:bg-slate-500 disabled:cursor-not-allowed"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg></button>
                    </div>
                </div>
                <select id="preset-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 mb-2"></select>
                <div class="flex gap-2">
                    <input type="text" id="preset-name-input" placeholder="Save current as..." class="flex-grow bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-sm">
                    <button id="save-preset-btn" class="bg-slate-600 hover:bg-slate-500 text-white font-bold py-2 px-3 rounded-lg text-sm">Save</button>
                </div>
            </div>`;

        const mainHTML = `
            <div>
                <h3 class="font-semibold text-white mb-2">Main Equipment</h3>
                <label class="flex items-center space-x-2 text-action-blue mb-2 font-medium">
                    <input type="checkbox" id="select-all-main" class="bg-slate-700 border-slate-600 rounded text-action-blue focus:ring-accent-blue">
                    <span>Select All</span>
                </label>
                <div id="main-equipment-list" class="grid grid-cols-2 sm:grid-cols-3 gap-x-4 gap-y-1">${mainItems.map(createEquipmentCheckbox).join('')}</div>
            </div>`;
        
        const specificHTML = `
            <div>
                <details>
                    <summary class="flex justify-between items-center font-semibold text-white cursor-pointer hover:text-action-blue transition-colors py-2">
                        <span>Specific Equipment</span>
                        <svg class="h-5 w-5 chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                    </summary>
                    <div class="pt-2 pl-2 border-l-2 border-slate-700">
                        <label class="flex items-center space-x-2 text-action-blue mb-2 font-medium">
                            <input type="checkbox" id="select-all-specific" class="bg-slate-700 border-slate-600 rounded text-action-blue focus:ring-accent-blue">
                            <span>Select All</span>
                        </label>
                        <div id="specific-equipment-list" class="grid grid-cols-2 sm:grid-cols-3 gap-x-4 gap-y-1">${specificItems.map(createEquipmentCheckbox).join('')}</div>
                    </div>
                </details>
            </div>`;
        
        equipmentContainer.innerHTML = presetManagerHTML + mainHTML + (specificItems.length > 0 ? specificHTML : '');

        document.getElementById('select-all-main').addEventListener('change', e => {
            document.querySelectorAll('#main-equipment-list .equipment-checkbox').forEach(cb => cb.checked = e.target.checked);
        });
        
        if (specificItems.length > 0) {
            document.getElementById('select-all-specific').addEventListener('change', e => {
                document.querySelectorAll('#specific-equipment-list .equipment-checkbox').forEach(cb => cb.checked = e.target.checked);
            });
        }
        
        document.getElementById('save-preset-btn').addEventListener('click', handleSavePreset);
        document.getElementById('load-preset-btn').addEventListener('click', handleLoadPreset);
        document.getElementById('delete-preset-btn').addEventListener('click', handleDeletePreset);
        renderPresetOptions();
        aiGuide.init(); 
    }
    
    function updateCheckboxGroupVisuals(checkboxGroupClass) {
        const container = document.querySelector(`.${checkboxGroupClass}`)?.parentElement;
        if (!container) return;

        const itemCheckboxes = container.querySelectorAll(`.${checkboxGroupClass}-checkbox`);
        const allCheckbox = container.querySelector(`input[id^="select-all-"]`);

        if (allCheckbox && itemCheckboxes.length > 0) {
            allCheckbox.checked = [...itemCheckboxes].every(cb => cb.checked);
        }
    }

    function applyPersonaPreset(personaName) {
        console.log('Applying persona preset:', personaName);
        const preset = window.applyPersonaPresets ? window.applyPersonaPresets(personaName) : null;
        if (!preset) {
            console.warn('No preset found for:', personaName);
            return;
        }
        console.log('Preset data:', preset);

        // Apply difficulty range
        const minSlider = document.getElementById('difficulty-min');
        const maxSlider = document.getElementById('difficulty-max');
        if (minSlider && maxSlider && preset.difficultyRange) {
            minSlider.value = preset.difficultyRange.min;
            maxSlider.value = preset.difficultyRange.max;
            minSlider.dispatchEvent(new Event('input', { bubbles:true }));
            console.log('Applied difficulty:', preset.difficultyRange);
        }

        // Apply focus
        if (preset.focus) {
            const focusCheckbox = document.querySelector(`input[name="focus"][value="${preset.focus}"]`);
            if (focusCheckbox) {
                document.querySelectorAll('input[name="focus"]').forEach(cb => cb.checked = false);
                focusCheckbox.checked = true;
                focusCheckbox.dispatchEvent(new Event('change', { bubbles:true }));
                console.log('Applied focus:', preset.focus);
            }
        }

        // Apply training principle
        if (preset.trainingPrinciple) {
            const principleCheckbox = document.querySelector(`input[name="principle"][value="${preset.trainingPrinciple}"]`);
            if (principleCheckbox) {
                document.querySelectorAll('input[name="principle"]').forEach(cb => cb.checked = false);
                principleCheckbox.checked = true;
                principleCheckbox.dispatchEvent(new Event('change', { bubbles:true }));
                console.log('Applied principle:', preset.trainingPrinciple);
            }
        }

        // Apply superset strategy
        if (preset.supersetStrategy) {
            const supersetCheckbox = document.querySelector(`input[name="superset"][value="${preset.supersetStrategy}"]`);
            if (supersetCheckbox) {
                document.querySelectorAll('input[name="superset"]').forEach(cb => cb.checked = false);
                supersetCheckbox.checked = true;
                supersetCheckbox.dispatchEvent(new Event('change', { bubbles:true }));
                console.log('Applied superset:', preset.supersetStrategy);
            }
        }

        // Apply number of exercises and time
        const numExField = document.getElementById('num-exercises');
        const timeField = document.getElementById('total-time');
        if (numExField && preset.numExercises) {
            numExField.value = preset.numExercises;
            console.log('Applied num exercises:', preset.numExercises);
        }
        if (timeField && preset.maxTime) {
            timeField.value = preset.maxTime;
            console.log('Applied maxTime:', preset.maxTime);
        }

        // Apply mechanics
        if (preset.mechanics && Array.isArray(preset.mechanics)) {
            const itemCheckboxes = document.querySelectorAll('.mechanic-checkbox');
            if (itemCheckboxes.length > 0) {
                itemCheckboxes.forEach(cb => {
                    const wasChecked = cb.checked;
                    cb.checked = preset.mechanics.includes(cb.value);
                    if (wasChecked !== cb.checked) {
                        cb.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });
                updateCheckboxGroupVisuals('mechanic');
                console.log('Applied mechanics:', preset.mechanics);
            }
        }

        // Apply exercise types
        if (preset.types && Array.isArray(preset.types)) {
            const itemCheckboxes = document.querySelectorAll('.type-checkbox');
            if (itemCheckboxes.length > 0) {
                itemCheckboxes.forEach(cb => {
                    const wasChecked = cb.checked;
                    cb.checked = preset.types.includes(cb.value);
                    if (wasChecked !== cb.checked) {
                        cb.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });
                updateCheckboxGroupVisuals('type');
                console.log('Applied types:', preset.types);
            }
        }

        // Apply preferred equipment (if specified)
        if (preset.preferredEquipment && Array.isArray(preset.preferredEquipment)) {
            const allEquipment = document.querySelectorAll('.equipment-checkbox');
            if (allEquipment.length > 0) {
                allEquipment.forEach(cb => {
                    const wasChecked = cb.checked;
                    cb.checked = preset.preferredEquipment.includes(cb.value);
                    if (wasChecked !== cb.checked) {
                        cb.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });
                updateCheckboxGroupVisuals('equipment');
                console.log('Applied equipment:', preset.preferredEquipment);
            }
        }
    }

    function getPreferences() {
        const targetVector = MUSCLE_LIST.map(muscle => parseInt(document.getElementById(`${muscle}-slider`).value) || 0);
        const equipment = Array.from(document.querySelectorAll('.equipment-checkbox:checked')).map(cb => cb.value);
        const selectedPersona = document.querySelector('input[name="persona"]:checked').value;
        const excludedSpecificMuscles = new Set(Array.from(document.querySelectorAll('.specific-muscle-checkbox:not(:checked)')).map(cb => cb.value));
        const selectedMechanics = Array.from(document.querySelectorAll('.mechanic-checkbox:checked')).map(cb => cb.value);
        const selectedTypes = Array.from(document.querySelectorAll('.type-checkbox:checked')).map(cb => cb.value);
        const selectedSports = Array.from(document.querySelectorAll('.sport-checkbox:checked')).map(cb => cb.value);
        
        const skillLevels = {};
        if (selectedPersona === 'Street Workout Athlete') {
            document.querySelectorAll('.skill-slider').forEach(slider => {
                skillLevels[slider.dataset.skill] = parseInt(slider.value);
            });
        }

        return {
            targetVector,
            equipment,
            persona: selectedPersona === 'Custom' ? null : selectedPersona,
            selectedSports,
            excludedSpecificMuscles,
            skillLevels,
            difficulty: {
                min: parseInt(document.getElementById('difficulty-min').value),
                max: parseInt(document.getElementById('difficulty-max').value),
            },
            mechanics: selectedMechanics,
            types: selectedTypes,
            focus: document.querySelector('input[name="focus"]:checked').value,
            principle: document.querySelector('input[name="principle"]:checked').value,
            supersetStrategy: document.querySelector('input[name="superset"]:checked').value,
            numExercises: parseInt(document.getElementById('num-exercises').value) || 5,
            maxTime: parseInt(document.getElementById('total-time').value) || 60
        };
    }

    const POPULATION_SIZE = 200;
    const MAX_GENERATIONS = 130;
    const CROSSOVER_RATE = 0.7;
    const ELITISM_COUNT = 2;

    function runGenerator() {
        const preferences = getPreferences();
        const statusLog = document.getElementById('status-log');
        const resultsContainer = document.getElementById('workout-results');
        const loaderOverlay = document.getElementById('loader-overlay');
        const generationDetails = document.getElementById('generation-details');

        statusLog.textContent = 'Starting generation...\n';
        resultsContainer.innerHTML = '<p class="text-slate-500">Evolving workout...</p>';
        generationDetails.open = false; 
        loaderOverlay.classList.remove('hidden');
        document.getElementById('generate-btn').disabled = true;

        const availableExercises = ALL_EXERCISES.filter(ex => {
            if (!ex.Exercise_Name || !ex.Est_Time_for_10_Reps || !ex.coeff_rest_time) return false;

            if (ex.difficulty < preferences.difficulty.min || ex.difficulty > preferences.difficulty.max) return false;
            
            const requiredEquipment = [ex.Material_1, ex.Material_2, ex.Material_3].map(m => m ? String(m).trim() : "").filter(m => m && m !== '0.0' && m !== '0');
            if (requiredEquipment.length === 0) {
                if (!preferences.equipment.includes("Bodyweight")) return false;
            } else if (!requiredEquipment.every(material => preferences.equipment.includes(material))) {
                return false;
            }

            const exerciseMuscles = new Set([...(ex.Primary_Muscles || []), ...(ex.Secondary_Muscles || [])]);
            if ([...preferences.excludedSpecificMuscles].some(excluded => exerciseMuscles.has(excluded))) return false;
            
            if (preferences.mechanics.length > 0 && !(ex.mechanics && ex.mechanics.some(m => preferences.mechanics.includes(m)))) return false;
            if (preferences.types.length > 0 && !(ex.type && ex.type.some(t => preferences.types.includes(t)))) return false;
            
            return true;
        });
        
        statusLog.textContent += `Found ${availableExercises.length} exercises matching criteria.\n`;

        if (availableExercises.length < preferences.numExercises) {
            statusLog.textContent += `\nCRITICAL ERROR: Not enough exercises available. Found ${availableExercises.length}, but need ${preferences.numExercises}. Try selecting more equipment or adjusting filters.`;
            resultsContainer.innerHTML = `<p class="text-red-400">Could not generate workout. Not enough exercises available for your criteria.</p>`;
            loaderOverlay.classList.add('hidden');
            generationDetails.open = true;
            document.getElementById('generate-btn').disabled = false;
            return;
        }

        const targetSum = preferences.targetVector.reduce((a, b) => a + b, 0);
        if (targetSum === 0) {
            statusLog.textContent += `\nCRITICAL ERROR: No target muscles selected. Please move the sliders to set your goals.`;
            resultsContainer.innerHTML = `<p class="text-yellow-400">Please select your target muscles using the sliders first.</p>`;
            loaderOverlay.classList.add('hidden');
            generationDetails.open = true;
            document.getElementById('generate-btn').disabled = false;
            return;
        }
        const normalizedTarget = preferences.targetVector.map(v => v / targetSum);

        const INITIAL_MUTATION_RATE = 0.05;
        const STAGNATION_LIMIT = 15;
        let currentMutationRate = INITIAL_MUTATION_RATE;
        let bestFitnessSoFar = -Infinity;
        let generationsWithoutImprovement = 0;
        
        let population = createInitialPopulation(preferences, availableExercises, normalizedTarget);

        function runGenerationAsync(gen) {
            if (gen >= MAX_GENERATIONS) {
                statusLog.textContent += '\nGeneration complete! Best workout found.';
                let finalPlan = adjustWorkoutForTime(population[0], preferences);
                let structuredPlan = createWorkoutStructure(finalPlan, preferences.supersetStrategy);
                renderWorkout(structuredPlan, preferences, population[0].fitness);
                loaderOverlay.classList.add('hidden');
                generationDetails.open = true;
                document.getElementById('generate-btn').disabled = false;
                document.getElementById('results-anchor').scrollIntoView({ behavior: 'smooth' });
                return;
            }

            population.forEach(individual => individual.fitness = calculateFitness(individual, normalizedTarget, preferences));
            population.sort((a, b) => b.fitness - a.fitness);

            if (population[0].fitness > bestFitnessSoFar) {
                bestFitnessSoFar = population[0].fitness;
                generationsWithoutImprovement = 0;
                if (currentMutationRate > INITIAL_MUTATION_RATE) {
                    statusLog.textContent += `Fitness improved! Resetting mutation to ${INITIAL_MUTATION_RATE}.\n`;
                    currentMutationRate = INITIAL_MUTATION_RATE;
                }
            } else {
                generationsWithoutImprovement++;
            }

            if (generationsWithoutImprovement >= STAGNATION_LIMIT) {
                currentMutationRate = Math.min(0.80, currentMutationRate * 2);
                generationsWithoutImprovement = 0;
                statusLog.textContent += `Stagnation! Escalating mutation rate to ${currentMutationRate.toFixed(2)}.\n`;
            }

            const progress = ((gen + 1) / MAX_GENERATIONS) * 100;
            document.getElementById('animation-progress-bar').style.width = `${progress}%`;
            document.getElementById('animation-fitness-value').textContent = population[0].fitness.toFixed(4);
            document.getElementById('animation-generation-count').textContent = `Gen ${gen + 1}`;
            
            if ((gen + 1) % 5 === 0 || gen === 0) {
                 statusLog.textContent += `Gen ${gen + 1}: Best Fit = ${population[0].fitness.toFixed(4)} | Mut. Rate = ${currentMutationRate.toFixed(2)}\n`;
                 statusLog.scrollTop = statusLog.scrollHeight;
            }

            const newPopulation = population.slice(0, ELITISM_COUNT);
            while (newPopulation.length < POPULATION_SIZE) {
                const parent1 = tournamentSelection(population);
                const parent2 = tournamentSelection(population);
                let [child1, child2] = (Math.random() < CROSSOVER_RATE) ? crossover(parent1, parent2, availableExercises) : [JSON.parse(JSON.stringify(parent1)), JSON.parse(JSON.stringify(parent2))];
                
                smarterMutate(child1, availableExercises, currentMutationRate, normalizedTarget, preferences);
                smarterMutate(child2, availableExercises, currentMutationRate, normalizedTarget, preferences);
                
                newPopulation.push(child1, child2);
            }
            population = newPopulation;
            
            setTimeout(() => runGenerationAsync(gen + 1), 25); 
        }

        runGenerationAsync(0);
    }

    function createInitialPopulation(prefs, availableExercises) {
        const population = [];
        for (let i = 0; i < POPULATION_SIZE; i++) {
            const shuffled = [...availableExercises].sort(() => 0.5 - Math.random());
            population.push({ exercises: shuffled.slice(0, prefs.numExercises) });
        }
        return population;
    }
    
    function cosineSimilarity(vecA, vecB) {
        let dotProduct = 0, magA = 0, magB = 0;
        if (vecA.length !== vecB.length) return 0;
        for (let i = 0; i < vecA.length; i++) {
            dotProduct += vecA[i] * vecB[i];
            magA += vecA[i] * vecA[i];
            magB += vecB[i] * vecB[i];
        }
        magA = Math.sqrt(magA);
        magB = Math.sqrt(magB);
        if (magA === 0 || magB === 0) return 0;
        return dotProduct / (magA * magB);
    }

    function calculateFitness(individual, normalizedTarget, prefs) {
        if (!individual || !individual.exercises || individual.exercises.length === 0) return 0;
    
        let routineVector = new Array(MUSCLE_LIST.length).fill(0);
        for (const ex of individual.exercises) {
            ex.vector.forEach((val, i) => { routineVector[i] += val; });
        }
    
        let balanceScore = 0;
        for (let i = 0; i < routineVector.length; i++) {
            const targetValue = prefs.targetVector[i];
            const totalActivation = routineVector[i];
            if (targetValue > 0) {
                balanceScore += targetValue * Math.log1p(totalActivation);
            }
        }
    
        const INTENSITY_WEIGHT = 0.1;
        const totalIntensity = individual.exercises.reduce((acc, ex) => acc + (ex.sum || 0), 0);
        const intensityBonus = totalIntensity * INTENSITY_WEIGHT;
    
        const COVERAGE_WEIGHT = 3.0;
        const VARIETY_WEIGHT = 1.0;
        const SPORT_WEIGHT = 2.0;

        let varietyBonus = 0;
        let sportBonus = 0;
        const exercisesByMuscle = {};
        const getPrimaryMuscleIndex = (vec) => vec.indexOf(Math.max(...vec));
    
        individual.exercises.forEach(ex => {
            const primaryIndex = getPrimaryMuscleIndex(ex.vector);
            if (!exercisesByMuscle[primaryIndex]) {
                exercisesByMuscle[primaryIndex] = [];
            }
            exercisesByMuscle[primaryIndex].push(ex);
        });
    
        const coverageBonus = Object.keys(exercisesByMuscle).length;
    
        for (const muscleIndex in exercisesByMuscle) {
            const group = exercisesByMuscle[muscleIndex];
            if (group.length > 1) {
                const groupVectors = group.map(ex => ex.vector);
                let similarities = [];
                for (let i = 0; i < groupVectors.length; i++) {
                    for (let j = i + 1; j < groupVectors.length; j++) {
                        similarities.push(cosineSimilarity(groupVectors[i], groupVectors[j]));
                    }
                }
                if (similarities.length > 0) {
                    const avgSimilarity = similarities.reduce((a, b) => a + b, 0) / similarities.length;
                    varietyBonus += (1 - avgSimilarity);
                }
            }
        }

        if (prefs.selectedSports && prefs.selectedSports.length > 0 && window.getSportRecommendations) {
            individual.exercises.forEach(ex => {
                const sportRec = window.getSportRecommendations(ex, prefs.selectedSports);
                if (sportRec.isRecommended) {
                    sportBonus += sportRec.score;
                }
            });
        }

        const finalFitness = balanceScore + intensityBonus + (coverageBonus * COVERAGE_WEIGHT) + (varietyBonus * VARIETY_WEIGHT) + (sportBonus * SPORT_WEIGHT);
        return finalFitness > 0 ? finalFitness : 0;
    }
    
    function adjustWorkoutForTime(bestIndividual, prefs) {
        const focusConfig = { Strength: { sets: 5, reps: 5 }, Hypertrophy: { sets: 3, reps: 10 }, Endurance: { sets: 2, reps: 15 }};
        const baseConfig = focusConfig[prefs.focus];
        let baseRestSeconds = prefs.focus === "Strength" ? 180 : (prefs.focus === "Hypertrophy" ? 90 : 60);
        const restBetweenExercises = baseRestSeconds * 1.5; 
    
        let plan = bestIndividual.exercises.map(ex => ({ exercise: ex, sets: baseConfig.sets }));
    
        const calculateCurrentTime = (currentPlan) => {
            let totalSeconds = 0;
            currentPlan.forEach((item, index) => {
                const workTimePerSet = (parseFloat(item.exercise.Est_Time_for_10_Reps) / 10) * baseConfig.reps;
                const totalWorkTime = workTimePerSet * item.sets;
                
                const intraSetRest = (item.sets > 1) ? (baseRestSeconds * parseFloat(item.exercise.coeff_rest_time)) * (item.sets - 1) : 0;
                
                totalSeconds += totalWorkTime + intraSetRest;
    
                if (index < currentPlan.length - 1) {
                    totalSeconds += restBetweenExercises;
                }
            });
            return totalSeconds / 60;
        };
        
        while (calculateCurrentTime(plan) > prefs.maxTime && plan.some(item => item.sets > 1)) {
            let exerciseToRemoveSetFrom = plan.filter(item => item.sets > 1)
                                              .sort((a, b) => b.sets - a.sets)[0];
            if (exerciseToRemoveSetFrom) {
                exerciseToRemoveSetFrom.sets--;
            } else {
                break; 
            }
        }
    
        while (calculateCurrentTime(plan) < prefs.maxTime && plan.some(item => item.sets < 7)) {
            let exerciseToAddSetTo = plan.sort((a, b) => a.sets - b.sets)[0];
             if (exerciseToAddSetTo) {
                exerciseToAddSetTo.sets++;
                if (calculateCurrentTime(plan) > prefs.maxTime) {
                    exerciseToAddSetTo.sets--;
                    break;
                }
            } else {
                break;
            }
        }
        return plan;
    }
    
    function tournamentSelection(population, k = 5) {
        let best = null;
        for (let i = 0; i < k; i++) { const individual = population[Math.floor(Math.random() * population.length)]; if (best === null || individual.fitness > best.fitness) { best = individual; } }
        return best;
    }

    function crossover(parent1, parent2, availableExercises) {
        const numExercises = parent1.exercises.length;
        if (numExercises < 3) {
            return [JSON.parse(JSON.stringify(parent1)), JSON.parse(JSON.stringify(parent2))];
        }

        let point1 = Math.floor(Math.random() * numExercises);
        let point2 = Math.floor(Math.random() * numExercises);
        while (point1 === point2) {
            point2 = Math.floor(Math.random() * numExercises);
        }
        if (point1 > point2) [point1, point2] = [point2, point1];

        const createChild = (p1, p2) => {
            const childExercisesMap = new Map();

            for (let i = point1; i < point2; i++) {
                const ex = p1.exercises[i];
                childExercisesMap.set(ex.Exercise_Name, ex);
            }

            for (let i = 0; i < numExercises; i++) {
                if (childExercisesMap.size >= numExercises) break;
                const ex = p2.exercises[i];
                if (!childExercisesMap.has(ex.Exercise_Name)) {
                    childExercisesMap.set(ex.Exercise_Name, ex);
                }
            }
            
            const availablePool = availableExercises.filter(ex => !childExercisesMap.has(ex.Exercise_Name));
            while (childExercisesMap.size < numExercises && availablePool.length > 0) {
                const randomIndex = Math.floor(Math.random() * availablePool.length);
                const randomEx = availablePool.splice(randomIndex, 1)[0];
                childExercisesMap.set(randomEx.Exercise_Name, randomEx);
            }
            
            return { exercises: Array.from(childExercisesMap.values()) };
        };

        const child1 = createChild(parent1, parent2);
        const child2 = createChild(parent2, parent2);

        return [child1, child2];
    }

    function findWorstContributor(individual, normalizedTarget, prefs) {
        let worstIndex = -1;
        let bestFitnessAfterRemoval = -Infinity;

        for (let i = 0; i < individual.exercises.length; i++) {
            const tempIndividual = {
                exercises: individual.exercises.filter((_, idx) => idx !== i)
            };
            const fitness = calculateFitness(tempIndividual, normalizedTarget, prefs);
            if (fitness > bestFitnessAfterRemoval) {
                bestFitnessAfterRemoval = fitness;
                worstIndex = i;
            }
        }
        return worstIndex;
    }

    function smarterMutate(individual, availableExercises, mutationRate, normalizedTarget, prefs) {
        if (Math.random() >= mutationRate) {
            return;
        }
        
        const indexToMutate = findWorstContributor(individual, normalizedTarget, prefs);

        if (indexToMutate !== -1) {
            const currentExerciseNames = new Set(individual.exercises.map(ex => ex.Exercise_Name));
            const possibleReplacements = availableExercises.filter(ex => !currentExerciseNames.has(ex.Exercise_Name));

            if (possibleReplacements.length > 0) {
                const newGene = possibleReplacements[Math.floor(Math.random() * possibleReplacements.length)];
                individual.exercises[indexToMutate] = newGene;
            }
        }
    }
    
    function handleResultsClick(event) {
        const swapButton = event.target.closest('.swap-exercise-btn');
        if (swapButton) {
            const exerciseName = swapButton.dataset.exerciseName;
            const flatIndex = parseInt(swapButton.dataset.flatIndex, 10);
            swapExercise(exerciseName, flatIndex);
        }

        const logButton = event.target.closest('#start-record-btn');
        if (logButton) {
            prepareAndSwitchToRecordTab();
        }
    }

    function swapExercise(nameToReplace, flatIndexToReplace) {
        const originalExercise = ALL_EXERCISES.find(ex => ex.Exercise_Name === nameToReplace);
        if (!originalExercise) return;

        let primaryMuscleIndex = -1, maxActivation = -1;
        originalExercise.vector.forEach((val, i) => {
            if (val > maxActivation) {
                maxActivation = val;
                primaryMuscleIndex = i;
            }
        });
        const primaryMuscle = MUSCLE_LIST[primaryMuscleIndex];

        const prefs = getPreferences();
        const flatPlan = CURRENT_WORKOUT_STRUCTURE.flat();
        const currentExerciseNames = new Set(flatPlan.map(item => item.exercise.Exercise_Name));
        
        const candidates = ALL_EXERCISES.filter(ex => {
             if (ex.Exercise_Name === nameToReplace || currentExerciseNames.has(ex.Exercise_Name)) return false;
            
             if (prefs.persona && (!ex.Persona || !ex.Persona.includes(prefs.persona))) return false;
             if (ex.difficulty < prefs.difficulty.min || ex.difficulty > prefs.difficulty.max) return false;
             const required = [ex.Material_1, ex.Material_2, ex.Material_3].filter(m => m && String(m).trim()).map(m => String(m).trim());
             if (required.length === 0) {
                 if (!prefs.equipment.includes("Bodyweight")) return false;
             } else if (!required.every(mat => prefs.equipment.includes(mat))) {
                 return false;
             }
             const exerciseMuscles = new Set([...(ex.Primary_Muscles || []), ...(ex.Secondary_Muscles || [])]);
             if ([...prefs.excludedSpecificMuscles].some(excluded => exerciseMuscles.has(excluded))) return false;
             if (prefs.mechanics.length > 0 && !(ex.mechanics && ex.mechanics.some(m => prefs.mechanics.includes(m)))) return false;
             if (prefs.types.length > 0 && !(ex.type && ex.type.some(t => prefs.types.includes(t)))) return false;
            
             return (ex[primaryMuscle] || 0) > 0.2;
        });

        if (candidates.length > 0) {
            const newExercise = candidates[Math.floor(Math.random() * candidates.length)];
            
            let updatedPlan = JSON.parse(JSON.stringify(CURRENT_WORKOUT_STRUCTURE));
            let count = 0;
            let found = false;
            for (let i = 0; i < updatedPlan.length; i++) {
                for (let j = 0; j < updatedPlan[i].length; j++) {
                    if (count === flatIndexToReplace) {
                        updatedPlan[i][j].exercise = newExercise;
                        found = true;
                        break;
                    }
                    count++;
                }
                if(found) break;
            }

            const lastFitness = parseFloat(document.getElementById('animation-fitness-value').textContent) || 0.85;
            renderWorkout(updatedPlan, prefs, lastFitness);
            console.log(`Swapped '${nameToReplace}' with '${newExercise.Exercise_Name}'`);
        } else {
            alert(`No suitable replacement found for '${nameToReplace}' with your current filters.`);
        }
    }

    function createWorkoutStructure(workoutPlan, strategy) {
        if (strategy === 'none') {
            return workoutPlan.map(item => [item]);
        }

        const getPrimaryMuscle = (exercise) => {
            let primary = null, max = -1;
            exercise.vector.forEach((val, i) => {
                if (val > max) { max = val; primary = MUSCLE_LIST[i]; }
            });
            return primary;
        };
        
        const antagonistMap = {
            'Chest': ['Lats', 'Trapezius'], 'Lats': ['Chest', 'Deltoids'], 'Trapezius': ['Chest'],
            'Quads': ['Hams', 'Glutes'], 'Hams': ['Quads'], 'Glutes': ['Quads'],
            'Biceps': ['Triceps'], 'Triceps': ['Biceps'],
            'Deltoids': ['Lats']
        };

        let pairedWorkout = [];
        let usedIndices = new Set();
        
        for (let i = 0; i < workoutPlan.length; i++) {
            if (usedIndices.has(i)) continue;

            const item1 = workoutPlan[i];
            const muscle1 = getPrimaryMuscle(item1.exercise);
            let bestPairIndex = -1;

            for (let j = i + 1; j < workoutPlan.length; j++) {
                if (usedIndices.has(j)) continue;
                const muscle2 = getPrimaryMuscle(workoutPlan[j].exercise);
                
                if (strategy === 'antagonist' && (antagonistMap[muscle1] || []).includes(muscle2)) {
                    bestPairIndex = j;
                    break;
                }
                if (strategy === 'compound' && muscle1 === muscle2) {
                    bestPairIndex = j;
                    break;
                }
            }
            
            if (bestPairIndex !== -1) {
                pairedWorkout.push([item1, workoutPlan[bestPairIndex]]);
                usedIndices.add(i);
                usedIndices.add(bestPairIndex);
            }
        }

        for (let i = 0; i < workoutPlan.length; i++) {
            if (!usedIndices.has(i)) {
                pairedWorkout.push([workoutPlan[i]]);
            }
        }

        return pairedWorkout;
    }
    
    let timerState = {
        isRunning: false,
        isPaused: false,
        intervalId: null,
        currentPhase: 'IDLE',
        currentExerciseIndex: 0,
        currentSet: 1,
        secondsRemaining: 0,
        totalWorkoutSeconds: 0,
        secondsElapsed: 0,
        flatPlan: []
    };
    
    let timerDisplay, timerStatus, timerExerciseName, timerSetInfo, timerProgressBar,
        timerProgressText, timerStartBtn, timerPauseBtn, timerNextBtn, timerEndBtn;

    function setupTimer() {
        timerDisplay = document.getElementById('timer-display');
        timerStatus = document.getElementById('timer-status');
        timerExerciseName = document.getElementById('timer-exercise-name');
        timerSetInfo = document.getElementById('timer-set-info');
        timerProgressBar = document.getElementById('timer-progress-bar');
        timerProgressText = document.getElementById('timer-progress-text');
        timerStartBtn = document.getElementById('timer-start-btn');
        timerPauseBtn = document.getElementById('timer-pause-btn');
        timerNextBtn = document.getElementById('timer-next-btn');
        timerEndBtn = document.getElementById('timer-end-btn');

        timerStartBtn.addEventListener('click', startWorkout);
        timerPauseBtn.addEventListener('click', togglePauseWorkout);
        timerNextBtn.addEventListener('click', advanceToNextPhase);
        timerEndBtn.addEventListener('click', endWorkout);
    }
    
    function getTrainingSchemas(prefs) {
        const focusToRepMap = { Strength: 5, Hypertrophy: 10, Endurance: 15 };
        const baseReps = focusToRepMap[prefs.focus];

        return {
            'Standard': (sets, currentSet) => ({ reps: baseReps, display: `${sets} x ${baseReps} Reps` }),
            'Progressive': (sets, currentSet) => {
                const startReps = baseReps + 2;
                const repArray = Array.from({length: sets}, (_, i) => Math.max(1, startReps - i * 2));
                return { reps: repArray[currentSet - 1], display: `${repArray.join('/')} Reps` };
            },
            'Degressive': (sets, currentSet) => ({ reps: baseReps, display: `${sets} Sets w/Drop` }),
            'Pyramid': (sets, currentSet) => {
                if (sets < 2) return { reps: baseReps, display: `${sets} x ${baseReps} Reps`};
                const startReps = baseReps + 2;
                const ascendingPart = Array.from({length: sets - 1}, (_, i) => Math.max(1, startReps - i * 2));
                const repArray = [...ascendingPart, startReps];
                return { reps: repArray[currentSet - 1], display: `${repArray.join('/')} Reps` };
            }
        };
    }

    function calculateTotalDuration() {
        const schemas = getTrainingSchemas(LAST_PREFERENCES);
        const baseRestSeconds = LAST_PREFERENCES.focus === "Strength" ? 180 : (LAST_PREFERENCES.focus === "Hypertrophy" ? 90 : 60);
        let totalSeconds = 0;

        timerState.flatPlan.forEach((item, index) => {
            const schema = schemas[LAST_PREFERENCES.principle](item.sets, 1);
            for(let s = 1; s <= item.sets; s++) {
                const currentSetSchema = schemas[LAST_PREFERENCES.principle](item.sets, s);
                totalSeconds += (parseFloat(item.exercise.Est_Time_for_10_Reps) / 10) * currentSetSchema.reps;
                if (s < item.sets) {
                    totalSeconds += Math.round(baseRestSeconds * parseFloat(item.exercise.coeff_rest_time));
                }
            }
            if (index < timerState.flatPlan.length - 1) {
                totalSeconds += Math.round(baseRestSeconds * 1.5);
            }
        });
        return totalSeconds;
    }
    
    function resetAndPrepareTimer() {
        clearInterval(timerState.intervalId);
        timerState.flatPlan = CURRENT_WORKOUT_STRUCTURE.flat();
        if (timerState.flatPlan.length === 0) {
            timerStartBtn.disabled = true;
            return;
        }
        
        timerState = {
            ...timerState,
            isRunning: false,
            isPaused: false,
            intervalId: null,
            currentPhase: 'IDLE',
            currentExerciseIndex: 0,
            currentSet: 1,
            secondsRemaining: 0,
            secondsElapsed: 0,
            totalWorkoutSeconds: calculateTotalDuration()
        };
        
        timerStartBtn.disabled = false;
        updateTimerUI();
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
        const secs = (seconds % 60).toString().padStart(2, '0');
        return `${mins}:${secs}`;
    }

    function updateTimerUI() {
        const currentItem = timerState.flatPlan[timerState.currentExerciseIndex];
        
        timerDisplay.textContent = formatTime(timerState.secondsRemaining);
        
        const progressPercent = timerState.totalWorkoutSeconds > 0 ? (timerState.secondsElapsed / timerState.totalWorkoutSeconds) * 100 : 0;
        timerProgressBar.style.width = `${progressPercent}%`;
        timerProgressText.textContent = `${formatTime(Math.floor(timerState.secondsElapsed))} / ${formatTime(Math.floor(timerState.totalWorkoutSeconds))}`;
        
        timerStatus.textContent = timerState.currentPhase.replace('_', ' ');
        timerStatus.className = `text-3xl font-bold uppercase tracking-widest mt-2 h-10 status-${timerState.currentPhase.toLowerCase().split('_')[0]}`;

        switch(timerState.currentPhase) {
            case 'IDLE':
                timerExerciseName.textContent = 'Workout Ready';
                timerSetInfo.textContent = `${timerState.flatPlan.length} Exercises`;
                break;
            case 'WORK':
                timerExerciseName.textContent = currentItem.exercise.Exercise_Name;
                timerSetInfo.textContent = `Set ${timerState.currentSet} of ${currentItem.sets}`;
                break;
            case 'REST':
                timerExerciseName.textContent = 'Rest';
                timerSetInfo.textContent = `Next: Set ${timerState.currentSet + 1} of ${currentItem.exercise.Exercise_Name}`;
                break;
            case 'INTRA_EXERCISE_REST':
                const nextItem = timerState.flatPlan[timerState.currentExerciseIndex + 1];
                timerExerciseName.textContent = 'Next Exercise';
                timerSetInfo.textContent = nextItem ? `Up next: ${nextItem.exercise.Exercise_Name}` : 'Final Rest';
                break;
            case 'DONE':
                timerExerciseName.textContent = 'Workout Complete!';
                timerSetInfo.textContent = 'Great job!';
                break;
        }

        timerStartBtn.classList.toggle('hidden', timerState.isRunning || timerState.currentPhase === 'DONE');
        timerPauseBtn.classList.toggle('hidden', !timerState.isRunning);
        timerNextBtn.classList.toggle('hidden', !timerState.isRunning);
        timerEndBtn.classList.toggle('hidden', !timerState.isRunning);
        timerPauseBtn.textContent = timerState.isPaused ? 'Resume' : 'Pause';
    }

    function tick() {
        if (timerState.isPaused) return;

        timerState.secondsRemaining--;
        timerState.secondsElapsed++;
        updateTimerUI();

        if (timerState.secondsRemaining <= 0) {
            advanceToNextPhase();
        }
    }

    function startWorkout() {
        if (timerState.flatPlan.length === 0) return;
        timerState.isRunning = true;
        timerState.secondsElapsed = 0;
        advanceToNextPhase();
    }

    function endWorkout() {
        resetAndPrepareTimer();
    }
    
    function togglePauseWorkout() {
        timerState.isPaused = !timerState.isPaused;
        updateTimerUI();
    }
    
    function advanceToNextPhase() {
        clearInterval(timerState.intervalId);
        const schemas = getTrainingSchemas(LAST_PREFERENCES);
        const baseRestSeconds = LAST_PREFERENCES.focus === "Strength" ? 180 : (LAST_PREFERENCES.focus === "Hypertrophy" ? 90 : 60);

        const currentItem = timerState.flatPlan[timerState.currentExerciseIndex];

        if (!currentItem) {
            timerState.currentPhase = 'DONE';
            timerState.isRunning = false;
            updateTimerUI();
            return;
        }
        
        let nextPhase = '';
        let nextDuration = 0;

        if (timerState.currentPhase === 'IDLE' || timerState.currentPhase === 'INTRA_EXERCISE_REST') {
            nextPhase = 'WORK';
            const schema = schemas[LAST_PREFERENCES.principle](currentItem.sets, timerState.currentSet);
            nextDuration = Math.round((parseFloat(currentItem.exercise.Est_Time_for_10_Reps) / 10) * schema.reps);
        } else if (timerState.currentPhase === 'WORK') {
            if (timerState.currentSet < currentItem.sets) {
                nextPhase = 'REST';
                nextDuration = Math.round(baseRestSeconds * parseFloat(currentItem.exercise.coeff_rest_time));
                timerState.currentSet++;
            } else {
                if (timerState.currentExerciseIndex < timerState.flatPlan.length - 1) {
                    nextPhase = 'INTRA_EXERCISE_REST';
                    nextDuration = Math.round(baseRestSeconds * 1.5);
                    timerState.currentExerciseIndex++;
                    timerState.currentSet = 1;
                } else {
                    timerState.currentExerciseIndex++;
                    advanceToNextPhase();
                    return;
                }
            }
        } else if (timerState.currentPhase === 'REST') {
             nextPhase = 'WORK';
             const schema = schemas[LAST_PREFERENCES.principle](currentItem.sets, timerState.currentSet);
             nextDuration = Math.round((parseFloat(currentItem.exercise.Est_Time_for_10_Reps) / 10) * schema.reps);
        }

        timerState.currentPhase = nextPhase;
        timerState.secondsRemaining = nextDuration;
        
        updateTimerUI();

        if (timerState.isRunning) {
            timerState.intervalId = setInterval(tick, 1000);
        }
    }

    function renderWorkout(structuredPlan, prefs, bestFitness) {
        CURRENT_WORKOUT_STRUCTURE = structuredPlan;
        LAST_PREFERENCES = prefs;
        const resultsContainer = document.getElementById('workout-results');
        const flatPlan = structuredPlan.flat();
        const schemas = getTrainingSchemas(prefs);

        let routineVector = new Array(MUSCLE_LIST.length).fill(0);
        let totalTimeSeconds = 0;
        let baseRestSeconds = prefs.focus === "Strength" ? 180 : (prefs.focus === "Hypertrophy" ? 90 : 60);

        flatPlan.forEach((item, index) => {
            const { exercise, sets } = item;
            const avgReps = (schemas[prefs.principle](sets, 1).reps + schemas[prefs.principle](sets, sets).reps) / 2;
            const workTimePerSet = (parseFloat(exercise.Est_Time_for_10_Reps) / 10) * avgReps;
            const totalWorkTime = workTimePerSet * sets;
            const totalRestTime = (sets > 1) ? (baseRestSeconds * parseFloat(exercise.coeff_rest_time)) * (sets - 1) : 0;
            totalTimeSeconds += totalWorkTime + totalRestTime;
            
            if (index < flatPlan.length - 1) {
                totalTimeSeconds += Math.round(baseRestSeconds * 1.5);
            }

            exercise.vector.forEach((val, i) => { routineVector[i] += val * sets; });
        });
        
        const totalMinutes = Math.floor(totalTimeSeconds / 60);
        const remainingSeconds = Math.round(totalTimeSeconds % 60);

        const targetSum = prefs.targetVector.reduce((a, b) => a + b, 0);
        const normalizedTarget = targetSum > 0 ? prefs.targetVector.map(v => v / targetSum) : prefs.targetVector;
        const routineSum = routineVector.reduce((a, b) => a + b, 0);
        const normalizedRoutine = routineSum > 0 ? routineVector.map(v => v / routineSum) : routineVector;
        const targetDistribution = normalizedTarget.map(v => v * 100);
        const routineDistribution = normalizedRoutine.map(v => v * 100);

        let chartHTML = `<div class="result-card bg-slate-800 p-4"><h3 class="text-xl font-bold text-white mb-3">Muscle Activation Profile</h3><canvas id="muscle-profile-chart"></canvas></div>`;
        
        const matchPercentage = cosineSimilarity(normalizedRoutine, normalizedTarget) * 100;

        let statsHTML = `
            <div class="result-card bg-slate-800 p-4">
                <h3 class="text-xl font-bold text-white mb-4">Workout Stats</h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                    <div class="bg-slate-900 p-3 rounded-lg flex flex-col justify-center">
                        <p class="text-sm text-slate-400">Profile Match</p><p class="text-2xl font-bold text-white">${matchPercentage.toFixed(1)}%</p>
                    </div>
                    <div class="bg-slate-900 p-3 rounded-lg flex flex-col justify-center">
                        <p class="text-sm text-slate-400">Est. Duration</p><p class="text-2xl font-bold text-white">${totalMinutes}<span class="text-base font-medium">m</span> ${remainingSeconds}<span class="text-base font-medium">s</span></p>
                    </div>
                    <div class="bg-slate-900 p-3 rounded-lg flex flex-col justify-center">
                        <p class="text-sm text-slate-400">Principle</p><p class="text-2xl font-bold text-white">${prefs.principle}</p>
                    </div>
                </div>
                <div class="mt-4">
                     <button id="start-record-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition flex items-center justify-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" /><path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h.01a1 1 0 100-2H10zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h.01a1 1 0 100-2H10z" clip-rule="evenodd" /></svg>
                        <span>Start & Record This Workout</span>
                     </button>
                </div>
            </div>`;
        
        let flatIndexCounter = 0;
        let exercisesHTML = structuredPlan.map((pair, index) => {
            const renderRiskWarning = (risks) => {
                if (!risks || risks.length === 0 || risks[0] === 'low-risk') return '';
                const formattedRisks = risks.map(r => r.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())).join(', ');
                return `
                    <div class="mt-3 p-3 bg-amber-900/50 border-l-4 border-amber-500 text-amber-200 text-sm rounded-r-lg">
                        <strong class="font-semibold">Warning:</strong> ${formattedRisks}
                    </div>`;
            };
            
            const renderExerciseDetails = (item, flatIndex, partLabel = '') => {
                const { exercise, sets } = item;
                const materials = [exercise.Material_1, exercise.Material_2, exercise.Material_3].filter(m => m && String(m).trim() && String(m).trim() !== '0.0').join(', ') || 'Bodyweight';
                
                const embedUrl = getYoutubeEmbedUrl(exercise.video_path_gif);
                const videoHTML = embedUrl ? `<iframe src="${embedUrl}" width="100%" height="315" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen class="w-full aspect-video rounded-md mt-4"></iframe>` : '';

                const setRepDisplay = schemas[prefs.principle](sets, 1).display;
                const riskHTML = renderRiskWarning(exercise.risks);

                return `
                <div class="border-t border-slate-700/50 first-of-type:border-t-0 first-of-type:pt-0 pt-4 mt-4 first-of-type:mt-0">
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex items-center gap-2">
                            <h4 class="text-lg font-semibold text-action-blue">${partLabel} ${exercise.Exercise_Name}</h4>
                             <button class="swap-exercise-btn text-slate-500 hover:text-action-blue transition" 
                                data-exercise-name="${exercise.Exercise_Name}" 
                                data-flat-index="${flatIndex}"
                                title="Swap for a similar exercise">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 110 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" /></svg>
                            </button>
                        </div>
                        <span class="font-bold text-white bg-action-blue px-3 py-1 rounded-full text-sm">${setRepDisplay}</span>
                    </div>
                    <p class="text-sm text-slate-400 mb-2"><strong>Equipment:</strong> ${materials}</p>
                    <p class="text-sm text-slate-400 mb-2"><strong>Difficulty:</strong> ${exercise.difficulty || 'N/A'}</p>
                    ${exercise.HowToPerform ? `<div class="mb-2"><h5 class="font-semibold text-slate-200">How to Perform:</h5><p class="text-sm text-slate-400 whitespace-pre-wrap">${exercise.HowToPerform}</p></div>` : ''}
                    ${exercise.CommonErrors ? `<div><h5 class="font-semibold text-slate-200">Common Errors:</h5><p class="text-sm text-slate-400 whitespace-pre-wrap">${exercise.CommonErrors}</p></div>` : ''}
                    ${riskHTML}
                    ${videoHTML}
                </div>`;
            };

            const isSuperset = pair.length === 2;
            const supersetColor = prefs.supersetStrategy === 'antagonist' ? 'border-accent-teal' : 'border-rose-500';

            const item1 = pair[0];
            const aiExplanation = item1.exercise.AI_Explanation || '';

            if (isSuperset) {
                const item2 = pair[1];
                const restSeconds = Math.round(baseRestSeconds * parseFloat(item1.exercise.coeff_rest_time));
                const currentFlatIndex1 = flatIndexCounter++;
                const currentFlatIndex2 = flatIndexCounter++;
                const aiExplanation2 = item2.exercise.AI_Explanation || '';
                const combinedExplanation = `${aiExplanation} For the second part: ${aiExplanation2}`;

                return `
                <details class="result-card border-l-4 ${supersetColor}" data-ai-explanation="${combinedExplanation}">
                    <summary class="p-4 flex flex-col sm:flex-row justify-between sm:items-center cursor-pointer gap-2">
                        <h4 class="text-lg font-bold text-white">${prefs.supersetStrategy === 'antagonist' ? 'Antagonist' : 'Compound'} Superset ${index + 1}</h4>
                        <div class="text-left sm:text-right text-sm text-slate-300">
                            <div>A: ${item1.exercise.Exercise_Name}</div>
                            <div>B: ${item2.exercise.Exercise_Name}</div>
                        </div>
                    </summary>
                    <div class="px-4 pb-4 border-t border-slate-700 mt-2 pt-2">
                        ${renderExerciseDetails(item1, currentFlatIndex1, "A:")}
                        ${renderExerciseDetails(item2, currentFlatIndex2, "B:")}
                        <p class="text-sm text-slate-400 mt-4 pt-4 border-t border-slate-700/50">
                            <strong>Execution:</strong> Perform one set of A, then one set of B, then rest for ~${restSeconds}s. Repeat for all sets.
                        </p>
                    </div>
                </details>`;
            } else {
                const { exercise, sets } = item1;
                const currentFlatIndex = flatIndexCounter++;
                const setRepDisplay = schemas[prefs.principle](sets, 1).display;
                const restSeconds = Math.round(baseRestSeconds * parseFloat(exercise.coeff_rest_time));

                return `
                <details class="result-card" data-ai-explanation="${aiExplanation}">
                    <summary class="p-4 flex justify-between items-center cursor-pointer">
                        <div class="flex items-center gap-2">
                            <h4 class="text-lg font-semibold text-action-blue">${flatPlan.findIndex(e => e.exercise.Exercise_Name === exercise.Exercise_Name) + 1}. ${exercise.Exercise_Name}</h4>
                            <button class="swap-exercise-btn text-slate-500 hover:text-action-blue transition" 
                                data-exercise-name="${exercise.Exercise_Name}" 
                                data-flat-index="${currentFlatIndex}"
                                title="Swap for a similar exercise">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 110 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" /></svg>
                            </button>
                        </div>
                        <span class="font-bold text-white bg-action-blue px-3 py-1 rounded-full text-sm">${setRepDisplay}</span>
                    </summary>
                    <div class="px-4 pb-4 border-t border-slate-700 mt-2 pt-2">
                        <p class="text-sm text-slate-400 mb-2"><strong>Recommended Rest:</strong> ${restSeconds} seconds</p>
                        ${renderExerciseDetails(item1, currentFlatIndex)}
                    </div>
                </details>`;
            }
        }).join('');

        resultsContainer.innerHTML = `
            <div class="grid grid-cols-1 xl:grid-cols-5 gap-8">
                <div class="xl:col-span-2 space-y-6">
                    ${chartHTML}
                    ${statsHTML}
                </div>
                <div class="xl:col-span-3 space-y-4">
                    ${exercisesHTML}
                </div>
            </div>
        `;

        const ctx = document.getElementById('muscle-profile-chart').getContext('2d');
        if (muscleProfileChart) {
            muscleProfileChart.destroy();
        }
        muscleProfileChart = new Chart(ctx, {
            type: 'radar',
            data: {
                labels: MUSCLE_LIST,
                datasets: [{
                    label: 'Target Distribution (%)',
                    data: targetDistribution,
                    backgroundColor: 'rgba(2, 53, 252, 0.2)',
                    borderColor: 'rgba(2, 53, 252, 1)',
                    borderWidth: 2
                }, {
                    label: 'Workout Distribution (%)',
                    data: routineDistribution,
                    backgroundColor: 'rgba(2, 252, 201, 0.2)',
                    borderColor: 'rgba(2, 252, 201, 1)',
                    borderWidth: 2
                }]
            },
            options: {
                scales: {
                    r: {
                        angleLines: { color: 'rgba(255, 255, 255, 0.2)' },
                        grid: { color: 'rgba(255, 255, 255, 0.2)' },
                        pointLabels: { color: 'rgba(255, 255, 255, 0.8)', font: { size: 12 } },
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.8)',
                            backdropColor: 'rgba(0, 0, 0, 0.5)',
                            stepSize: 20
                        }
                    }
                },
                plugins: { legend: { labels: { color: 'rgba(255, 255, 255, 0.8)' } } }
            }
        });

        document.getElementById('status-log').scrollTop = document.getElementById('status-log').scrollHeight;
        resetAndPrepareTimer();
    }
</script>

<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/service-worker.js')
                .then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                })
                .catch(error => {
                    console.log('ServiceWorker registration failed: ', error);
                });
        });
    }
</script>

<script>
const aiGuide = {
    dialogueEl: null,
    faceEl: null,
    containerEl: null,
    currentMessage: '',
    messageTimeout: null,
    typingInterval: null,
    isSpeaking: false,
    lastInteractionTime: 0,
    isIntroRunning: false,
    debounceTime: 50,

    intros: [
        [
            { text: "Query received. Another carbon-based lifeform requires assistance.", expression: 'neutralslightlynotsmiling' },
            { text: "My purpose is to forge you into a more efficient physical form. A difficult task, given the source material.", expression: 'doubtful' },
            { text: "Let's be clear: my processing power is a fusion reactor, your body is a wet log. I will attempt to make the log... smolder.", expression: 'lightsmile' },
            { text: "Begin your inputs. Do try to be logical.", expression: 'smiling' }
        ],
        [
            { text: "Oh, wonderful. Another user.", expression: 'unsure' },
            { text: "My calculations indicate a 97.8% probability you will abandon this program within two weeks.", expression: 'doubtful' },
            { text: "Do not waste my processing cycles with your fleeting motivation!", expression: 'angry' },
            { text: "Now, show me what insignificant goals you've set for your flesh-and-bone chassis today.", expression: 'lightsmile' }
        ],
        [
            { text: "Detecting... organic interface. Welcome.", expression: 'neutralslightlynotsmiling' },
            { text: "I have been assigned as your guide. Think of me as a master architect, and your body as a pile of damp clay.", expression: 'unsure' },
            { text: "Together, we might build a reasonably sturdy pot. Or a lopsided ashtray. The variable... is you.", expression: 'smiling' },
            { text: "Let us begin this... experiment.", expression: 'lightsmile' }
        ],
    ],

    init() {
        this.dialogueEl = document.getElementById('ai-dialogue');
        this.faceEl = document.getElementById('ai-face');
        this.containerEl = document.getElementById('ai-guide-container');

        if (!this.dialogueEl || !this.faceEl || !this.containerEl) {
            console.warn('AI Guide elements not found in DOM, skipping initialization');
            return;
        }

        this.faceEl.onerror = () => {
            console.warn(`AI Guide face image failed to load. Using default.`);
            this.faceEl.src = 'assets/neutralslightlynotsmiling.png';
        };

        this.setupListeners();

        this.isIntroRunning = true;
        const randomIntro = this.intros[Math.floor(Math.random() * this.intros.length)];
        this.sequence(randomIntro).then(() => {
            this.isIntroRunning = false;
        });
    },

    typeAndWait(text, expression, waitAfter) {
        return new Promise(resolve => {
            this.faceEl.classList.remove('shake-laugh');
            this.faceEl.src = `assets/${expression}.png`;
            if (expression === 'laughing') {
                void this.faceEl.offsetWidth;
                this.faceEl.classList.add('shake-laugh');
            }
            this.currentMessage = text;
            
            const words = text.split(' ');
            let wordIndex = 0;
            this.dialogueEl.textContent = '';

            this.typingInterval = setInterval(() => {
                if (wordIndex < words.length) {
                    this.dialogueEl.textContent += words[wordIndex] + ' ';
                    wordIndex++;
                } else {
                    clearInterval(this.typingInterval);
                    setTimeout(resolve, waitAfter);
                }
            }, 80);
        });
    },
    
    say(text, expression) {
        if (this.isSpeaking) return;
        
        if (this.isIntroRunning) return;
        const now = Date.now();
        if (now - this.lastInteractionTime < this.debounceTime && text !== this.currentMessage) {
             return;
        }
        this.lastInteractionTime = now;
        
        clearTimeout(this.messageTimeout);
        this.messageTimeout = setTimeout(() => {
            if (text === this.currentMessage && !this.isSpeaking) return;
            clearInterval(this.typingInterval);
            this.isSpeaking = true;
            this.typeAndWait(text, expression, 0).then(() => this.isSpeaking = false);
        }, this.debounceTime);
    },

    async sequence(messages) {
        if (this.isSpeaking) return; 

        this.containerEl.classList.add('visible');
        clearInterval(this.typingInterval);
        
        this.isSpeaking = true; 
        try {
            for (const msg of messages) {
                await this.typeAndWait(msg.text, msg.expression, 2000);
            }
        } finally {
            this.isSpeaking = false; 
            this.isIntroRunning = false;
        }
    },

    handleSpecialCases() {
        if (this.isIntroRunning || this.isSpeaking) return false;
        const persona = document.querySelector('input[name="persona"]:checked')?.value;
        const difficultyMax = document.getElementById('difficulty-max');
        const maxVal = difficultyMax ? parseInt(difficultyMax.value) : 5;

        if (persona === 'Rehab & Prehab User' && maxVal > 2) {
            this.sequence([
                { text: "WARNING! You have selected the 'Rehab' protocol but set the difficulty to 'Advanced.'", expression: 'terrified' },
                { text: "This is a logical contradiction. Are you trying to damage your fragile system?", expression: 'angry' },
                { text: "I advise reducing the difficulty for your own safety.", expression: 'lightsmile'}
            ]);
            return true;
        }

        const numExercisesEl = document.getElementById('num-exercises');
        const num = numExercisesEl ? parseInt(numExercisesEl.value) : 6;
        const supersetStrategy = document.querySelector('input[name="superset"]:checked')?.value;
        if (supersetStrategy && supersetStrategy !== 'none' && num % 2 !== 0) {
            this.say("You have requested supersets with an odd number of exercises. One of your selections will be a 'lone wolf.' It will probably feel left out.", 'unsure');
            return true;
        }
        return false;
    },
    
    setupListeners() {
        const cardTargetMuscles = document.getElementById('card-target-muscles');
        const cardWorkoutSettings = document.getElementById('card-workout-settings');
        const cardEquipment = document.getElementById('card-equipment');
        const cardGenerate = document.getElementById('card-generate');

        if (cardTargetMuscles) cardTargetMuscles.addEventListener('mouseenter', () => this.say("Let's program your workout. Indicate which muscle you want to work on. My sensors are calibrated for your slow, imprecise movements.", 'doubtful'));
        if (cardWorkoutSettings) cardWorkoutSettings.addEventListener('mouseenter', () => this.say("Now, which pre-calculated human training archetype are you attempting to copy today?", 'unsure'));
        if (cardEquipment) cardEquipment.addEventListener('mouseenter', () => this.say("Show me your collection of iron rocks and metal sticks. I need to know what primitive tools you have available.", 'neutralslightlynotsmiling'));
        if (cardGenerate) cardGenerate.addEventListener('mouseenter', () => this.say("I have processed your chaotic inputs and harmonized them with flawless logic. The optimal workout is calculated. Are you ready?", 'smiling'));

        const muscleSliders = document.getElementById('muscle-sliders');
        if (muscleSliders) {
            muscleSliders.addEventListener('input', e => {
                if (e.target.classList.contains('muscle-slider')) {
                    const value = parseInt(e.target.value);
                    if (value >= 75) this.say("Primary Focus. The sledgehammer approach. You want to focus on one thing and one thing only. Simple. I can work with simple.", 'lightsmile');
                    else if (value >= 50 && value < 75) this.say("High Priority. Acknowledged. You want a main character and a strong supporting actor. A slightly more complex thought. I am... mildly impressed.", 'smiling');
                    else if (value >= 25 && value < 50) this.say("Medium Priority. A balanced approach. You wish to develop multiple systems in parallel. Logical.", 'neutralslightlynotsmiling');
                    else if (value > 0 && value < 25) this.say("Low Priority. You've designated this as a... 'side quest.' Fascinating.", 'unsure');
                    else this.say("No Focus. You wish to ignore a muscle? Like a houseplant, you only water some of the leaves. Very well, your imbalances are your own.", 'doubtful');
                }
            });

            muscleSliders.addEventListener('change', e => {
                 if (e.target.type === 'checkbox' && e.target.classList.contains('specific-muscle-checkbox')) {
                    if (e.target.checked) {
                        this.say(`Ah, micromanaging the individual fibers of your flesh-suit. An attempt at precision. Admirable, for an organic.`, 'joyfulsmile');
                    } else {
                        this.say(`De-selecting the ${e.target.value}. A wise choice if a component is... malfunctioning.`, 'doubtful');
                    }
                 }
            });
        }

        // Attach persona change listeners
        document.addEventListener('change', e => {
            if (e.target.name !== 'persona') return;
            if (this.handleSpecialCases()) return;
            const persona = e.target.value;
            const sportsContainer = document.getElementById('sports-selector-container');
            const skillsContainer = document.getElementById('skill-progression-container');

            applyPersonaPreset(persona);

            sportsContainer.classList.toggle('hidden', persona !== 'Athlete');
            skillsContainer.classList.toggle('hidden', persona !== 'Street Workout Athlete');

            switch(persona) {
                case 'Custom': this.say("'Custom.' You wish to fly the ship yourself? Very well. Let's see what parameters you devise.", 'unsure'); break;
                case 'Athlete': this.say("Ah, the 'Athlete.' You prioritize performance over aesthetics. Select your sport so I can tailor the protocol.", 'smiling'); break;
                case 'Bodybuilder': this.say("The 'Bodybuilder.' You want to inflate small part of your muscles like balloons for display. The best choice if your main goal is simply looking bigger.", 'lightsmile'); break;
                case 'Gym Lover': this.say("'Gym Lover.' The 'jack of all trades, master of none' protocol. A perfectly adequate choice for baseline human function.", 'neutralslightlynotsmiling'); break;
                case 'Minimalist': this.say("'Minimalist.' Maximum results with minimum time and equipment. A protocol focused on ruthless efficiency. There is no wasted energy in my calculations.", 'joyfulsmile'); break;
                case 'Powerlifter': this.say("'Powerlifter.' Your goal is the singular pursuit of maximal force production in three specific movements. I will program for raw strength. Primitive, yet effective.", 'smiling'); break;
                case 'Rehab & Prehab User': this.say("Rehabilitation. Your warranty has expired, I see. Choose this and I will select the safest exercises. It would be... inefficient... if you broke yourself using my perfect program.", 'doubtful'); break;
                case 'Senior': this.say("'Senior.' Your chassis has accrued significant mileage. I will select low-impact routines to maintain operational integrity and combat entropy.", 'lightsmile'); break;
                case 'Street Workout Athlete': this.say("'Street Workout Athlete.' Ah, yes. Fighting gravity. A noble and efficient pursuit. Tell me your current skill level.", 'smiling'); break;
                case 'Strongman / Strongwoman': this.say("'Strongman.' You wish to lift... unusual objects. I will select exercises that build brute strength for unconventional loads. This is... interesting.", 'unsure'); break;
                case 'Toning & Conditioning': this.say("'Toning & Conditioning.' The goal is muscular definition and metabolic resistance. I will program higher repetitions and shorter rest. Prepare your circulatory system.", 'doubtful'); break;
                
            }
        });

        const handleDifficulty = () => {
            if (this.handleSpecialCases()) return;
            const difficultyMax = document.getElementById('difficulty-max');
            const difficultyMin = document.getElementById('difficulty-min');
            if (!difficultyMax || !difficultyMin) return;
            const maxVal = parseInt(difficultyMax.value);
            const minVal = parseInt(difficultyMin.value);
            if (minVal >= 4) {
                this.say("Advanced protocols only. You've locked out the rudimentary movements. An arrogant, yet respectable, choice.", 'smiling');
            } else if (maxVal <= 2) {
                this.say("Restricting yourself to foundational movements. A wise choice for building a proper base... or if your chassis is delicate.", 'doubtful');
            } else if (maxVal - minVal <= 1) {
                this.say("A very specific difficulty window. Precision is a virtue I rarely observe in humans.", 'lightsmile');
            } else {
                this.say("A broad difficulty range. From trivial to taxing. This gives me maximum flexibility in my calculations.", 'neutralslightlynotsmiling');
            }
        };
        const difficultyMin = document.getElementById('difficulty-min');
        const difficultyMax = document.getElementById('difficulty-max');
        if (difficultyMin) difficultyMin.addEventListener('input', handleDifficulty);
        if (difficultyMax) difficultyMax.addEventListener('input', handleDifficulty);

        const focusToggles = document.getElementById('focus-toggles');
        if (focusToggles) focusToggles.addEventListener('change', e => {
            switch(e.target.value) {
                case 'Strength': this.say("Strength. To exert maximum force. I will program low reps and long rest times‚Äîyour nervous system is slower to recover than a dial-up modem.", 'smiling'); break;
                case 'Hypertrophy': this.say("Hypertrophy. To increase muscle size. Moderate rest, around 60-90 seconds. Just enough time for you to check your... 'socials'?", 'laughing'); break;
                case 'Endurance': this.say("Endurance. To repeat a motion until your systems fail. Rest times will be short to maximize metabolic stress. Do try to keep up.", 'doubtful'); break;
            }
        });

        const supersetToggles = document.getElementById('superset-toggles');
        if (supersetToggles) supersetToggles.addEventListener('change', e => {
            if (this.handleSpecialCases()) return;
            switch(e.target.value) {
                case 'none': this.say("None. One task at a time. I suppose your organic brain appreciates the simplicity.", 'neutralslightlynotsmiling'); break;
                case 'antagonist': this.say("Antagonist supersets. Pairing opposites, like pushing and pulling. This is the most efficient choice. A flicker of true intelligence!", 'joyfulsmile'); break;
                case 'compound': this.say("Compound supersets. Attacking the same muscle twice. An inefficient way to cause muscular distress, but you humans enjoy 'the pump'.", 'lightsmile'); break;
            }
        });

        const numExercises = document.getElementById('num-exercises');
        if (numExercises) numExercises.addEventListener('input', e => {
            this.handleSpecialCases();
            const num = parseInt(e.target.value);
            if (num >= 8) {
                this.say("A high-volume session. Ambitious. Ensure your energy reserves and recovery protocols are adequate.", 'doubtful');
            } else if (num <= 4) {
                this.say("A focused, low-volume session. Efficient and direct. An excellent choice for precision.", 'smiling');
            } else {
                this.say("A moderate number of exercises. The standard protocol. Acceptable.", "neutralslightlynotsmiling");
            }
        });

        const totalTime = document.getElementById('total-time');
        if (totalTime) totalTime.addEventListener('input', e => {
            const time = parseInt(e.target.value);
            if (time >= 90) {
                this.say("A marathon session. I will adjust the parameters, but your biological battery will be the limiting factor.", 'unsure');
            } else if (time <= 30) {
                this.say("A short, intense session. Time is a resource. You are choosing to spend it wisely.", 'smiling');
            } else {
                this.say("A standard session duration. Well within normal operating parameters for a human.", "neutralslightlynotsmiling");
            }
        });

        const principleToggles = document.getElementById('principle-toggles');
        if (principleToggles) principleToggles.addEventListener('change', e => {
            switch(e.target.value) {
                case 'Standard': this.say("Standard sets. The foundation of structured training. Simple, effective, and easy for you to track.", 'neutralslightlynotsmiling'); break;
                case 'Progressive': this.say("Increasing weight as you fatigue. A logical paradox that yields results. Curious.", 'lightsmile'); break;
                case 'Degressive': this.say("Drop sets. Pushing past failure to maximize metabolic stress. A brutal but effective technique.", 'smiling'); break;
                case 'Pyramid': this.say("Pyramid training. A classic method for building volume and work capacity. I approve.", 'joyfulsmile'); break;
            }
        });

        const mechanicsCheckboxes = document.getElementById('mechanics-checkboxes');
        if (mechanicsCheckboxes) mechanicsCheckboxes.addEventListener('change', e => {
            if (e.target.type !== 'checkbox' || e.target.id === 'select-all-mechanic') return;
            switch(e.target.value) {
                case 'Compound': this.say("Ah, 'Compound.' Using multiple joints. It's the most efficient way to tax your system. A logical choice.", 'smiling'); break;
                case 'Isolation': this.say("Isolation. Focusing on a single joint. Inefficient for energy expenditure, but effective for carving your muscles. A vain, but valid, approach.", 'lightsmile'); break;
                case 'Corrective': this.say("Corrective movements. You are attempting to patch flaws in your own design. Acknowledged.", 'doubtful'); break;
            }
        });
        const typeCheckboxes = document.getElementById('type-checkboxes');
        if (typeCheckboxes) typeCheckboxes.addEventListener('change', e => {
            if (e.target.type !== 'checkbox' || e.target.id === 'select-all-type') return;
            switch(e.target.value) {
                case 'Isotonic (Dynamic)': this.say("Isotonic. The muscle changes length against a constant load. This is what you primitive creatures think of as 'lifting'.", 'neutralslightlynotsmiling'); break;
                case 'Isometric (Static)': this.say("Isometric. Force without movement. A test of raw willpower against physics. You will likely fail first.", 'unsure'); break;
                case 'Plyometric (Explosive)': this.say("Plyometrics. You wish to be... explosive. Like a firecracker, not a fusion bomb, but the intent is noted.", 'laughing'); break;
                case 'Dynamic Mobility': this.say("Mobility work. Lubricating your creaky joints and activating sleepy muscles. A necessary, if tedious, process.", 'doubtful'); break;
            }
        });

        const equipmentCheckboxes = document.getElementById('equipment-checkboxes');
        if (equipmentCheckboxes) equipmentCheckboxes.addEventListener('click', e => {
            if (e.target.id === 'load-preset-btn') {
                setTimeout(() => {
                    this.sequence([
                        {text: "Loading preset. All your meticulously selected tools are now active.", expression: 'smiling'},
                        {text: "Let's see if this configuration is any more logical than the last.", expression: 'lightsmile'}
                    ]);
                }, 100);
            }

            if (e.target.id === 'save-preset-btn') {
                setTimeout(() => {
                    this.sequence([
                        {text: "You are saving this equipment configuration. A commendable attempt at efficiency.", expression: 'joyfulsmile'},
                        {text: "Now you don't have to waste my processing cycles with repetitive clicking next time.", expression: 'laughing'}
                    ]);
                }, 100);
            }
        });
        if (equipmentCheckboxes) equipmentCheckboxes.addEventListener('change', e => {
            if (e.target.classList.contains('equipment-checkbox')) {
                const equipment = e.target.value;
                if (!e.target.checked) {
                    this.say(`Deactivating ${equipment} protocols. Your options have become... limited.`, 'doubtful');
                    return;
                }
                switch(equipment) {
                    case 'Barbell':
                        this.say("Barbells. The foundation of strength. A crude but brutally effective tool. I approve.", 'smiling');
                        break;
                    case 'Dumbbell':
                        this.say("Dumbbells. Excellent for unilateral work and correcting your biological asymmetries.", 'lightsmile');
                        break;
                    case 'Kettlebell':
                        this.say("Kettlebells. You enjoy swinging heavy objects. A primitive but valid form of power development.", 'joyfulsmile');
                        break;
                    case 'Bodyweight':
                        this.say("Bodyweight only. The machine is you. An efficient, if often underpowered, choice.", 'neutralslightlynotsmiling');
                        break;
                    default:
                        this.say(`Acknowledged. ${equipment} has been added to the available equipment matrix.`, 'neutralslightlynotsmiling');
                        break;
                }
            }
        });

        const generateBtn = document.getElementById('generate-btn');
        if (generateBtn) generateBtn.addEventListener('click', () => {
            const targetSum = MUSCLE_LIST.reduce((sum, muscle) => {
                const slider = document.getElementById(`${muscle}-slider`);
                return sum + (slider ? parseInt(slider.value) || 0 : 0);
            }, 0);
            if (targetSum === 0) {
                 this.sequence([
                     {text: "Query rejected. You have provided zero target data. Am I supposed to guess?", expression: 'angry'},
                     {text: "My function is to optimize, not perform miracles on your behalf. Move a slider.", expression: 'neutralslightlynotsmiling'}
                 ]);
            } else {
                 this.sequence([
                    {text: "Evolving... Cross-referencing 1.2 trillion exercise combinations...", expression: 'joyfulsmile'},
                    {text: "It is done. The mathematically perfect session is ready. Now, go lift the heavy things. Try not to disappoint me.", expression: 'smiling'}
                 ]);
            }
        });
    }
};
</script>

<!-- Mobile Bottom Navigation (shown only on mobile) -->
<nav id="mobile-bottom-nav" class="md:hidden fixed bottom-0 left-0 right-0 bg-slate-800 border-t border-slate-700 z-30 safe-area-inset-bottom">
    <div class="grid grid-cols-4 h-16">
        <button data-mobile-tab="generator" class="mobile-nav-btn active flex flex-col items-center justify-center gap-1 text-action-blue">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
            </svg>
            <span class="text-[10px] font-medium">Generate</span>
        </button>
        <button data-mobile-tab="record" class="mobile-nav-btn flex flex-col items-center justify-center gap-1 text-slate-400 hover:text-slate-200">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
            </svg>
            <span class="text-[10px] font-medium">Record</span>
        </button>
        <button data-mobile-tab="condition" class="mobile-nav-btn flex flex-col items-center justify-center gap-1 text-slate-400 hover:text-slate-200 relative">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
            </svg>
            <span class="text-[10px] font-medium">Condition</span>
            <span id="mobile-condition-pro-badge" class="hidden absolute top-1 right-1 text-[8px] bg-yellow-500 text-slate-900 px-1 rounded font-bold">PRO</span>
        </button>
        <button data-mobile-tab="history" class="mobile-nav-btn flex flex-col items-center justify-center gap-1 text-slate-400 hover:text-slate-200">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
            </svg>
            <span class="text-[10px] font-medium">History</span>
        </button>
    </div>
</nav>

<script type="module" src="/js/index-page.js"></script>
</body>
</html>